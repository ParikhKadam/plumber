// Code generated by counterfeiter. DO NOT EDIT.
package etcdfakes

import (
	"context"
	"sync"
	"time"

	"github.com/batchcorp/plumber-schemas/build/go/protos"
	"github.com/batchcorp/plumber-schemas/build/go/protos/common"
	"github.com/batchcorp/plumber-schemas/build/go/protos/opts"
	"github.com/batchcorp/plumber/config"
	"github.com/batchcorp/plumber/embed/etcd"
	clientv3 "go.etcd.io/etcd/client/v3"
)

type FakeIEtcd struct {
	BroadcastStub        func(context.Context, *etcd.Message) error
	broadcastMutex       sync.RWMutex
	broadcastArgsForCall []struct {
		arg1 context.Context
		arg2 *etcd.Message
	}
	broadcastReturns struct {
		result1 error
	}
	broadcastReturnsOnCall map[int]struct {
		result1 error
	}
	ClientStub        func() *clientv3.Client
	clientMutex       sync.RWMutex
	clientArgsForCall []struct {
	}
	clientReturns struct {
		result1 *clientv3.Client
	}
	clientReturnsOnCall map[int]struct {
		result1 *clientv3.Client
	}
	DeleteStub        func(context.Context, string, ...clientv3.OpOption) (*clientv3.DeleteResponse, error)
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []clientv3.OpOption
	}
	deleteReturns struct {
		result1 *clientv3.DeleteResponse
		result2 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 *clientv3.DeleteResponse
		result2 error
	}
	DirectStub        func(context.Context, string, *etcd.Message) error
	directMutex       sync.RWMutex
	directArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 *etcd.Message
	}
	directReturns struct {
		result1 error
	}
	directReturnsOnCall map[int]struct {
		result1 error
	}
	GetStub        func(context.Context, string, ...clientv3.OpOption) (*clientv3.GetResponse, error)
	getMutex       sync.RWMutex
	getArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []clientv3.OpOption
	}
	getReturns struct {
		result1 *clientv3.GetResponse
		result2 error
	}
	getReturnsOnCall map[int]struct {
		result1 *clientv3.GetResponse
		result2 error
	}
	GrantLeaseStub        func(context.Context, int64) (*clientv3.LeaseGrantResponse, error)
	grantLeaseMutex       sync.RWMutex
	grantLeaseArgsForCall []struct {
		arg1 context.Context
		arg2 int64
	}
	grantLeaseReturns struct {
		result1 *clientv3.LeaseGrantResponse
		result2 error
	}
	grantLeaseReturnsOnCall map[int]struct {
		result1 *clientv3.LeaseGrantResponse
		result2 error
	}
	PublishConfigUpdateStub        func(context.Context, *etcd.MessageUpdateConfig) error
	publishConfigUpdateMutex       sync.RWMutex
	publishConfigUpdateArgsForCall []struct {
		arg1 context.Context
		arg2 *etcd.MessageUpdateConfig
	}
	publishConfigUpdateReturns struct {
		result1 error
	}
	publishConfigUpdateReturnsOnCall map[int]struct {
		result1 error
	}
	PublishCreateCompositeStub        func(context.Context, *opts.Composite) error
	publishCreateCompositeMutex       sync.RWMutex
	publishCreateCompositeArgsForCall []struct {
		arg1 context.Context
		arg2 *opts.Composite
	}
	publishCreateCompositeReturns struct {
		result1 error
	}
	publishCreateCompositeReturnsOnCall map[int]struct {
		result1 error
	}
	PublishCreateConnectionStub        func(context.Context, *opts.ConnectionOptions) error
	publishCreateConnectionMutex       sync.RWMutex
	publishCreateConnectionArgsForCall []struct {
		arg1 context.Context
		arg2 *opts.ConnectionOptions
	}
	publishCreateConnectionReturns struct {
		result1 error
	}
	publishCreateConnectionReturnsOnCall map[int]struct {
		result1 error
	}
	PublishCreateDynamicStub        func(context.Context, *opts.DynamicOptions) error
	publishCreateDynamicMutex       sync.RWMutex
	publishCreateDynamicArgsForCall []struct {
		arg1 context.Context
		arg2 *opts.DynamicOptions
	}
	publishCreateDynamicReturns struct {
		result1 error
	}
	publishCreateDynamicReturnsOnCall map[int]struct {
		result1 error
	}
	PublishCreateReadStub        func(context.Context, *opts.ReadOptions) error
	publishCreateReadMutex       sync.RWMutex
	publishCreateReadArgsForCall []struct {
		arg1 context.Context
		arg2 *opts.ReadOptions
	}
	publishCreateReadReturns struct {
		result1 error
	}
	publishCreateReadReturnsOnCall map[int]struct {
		result1 error
	}
	PublishCreateRelayStub        func(context.Context, *opts.RelayOptions) error
	publishCreateRelayMutex       sync.RWMutex
	publishCreateRelayArgsForCall []struct {
		arg1 context.Context
		arg2 *opts.RelayOptions
	}
	publishCreateRelayReturns struct {
		result1 error
	}
	publishCreateRelayReturnsOnCall map[int]struct {
		result1 error
	}
	PublishCreateSchemaStub        func(context.Context, *protos.Schema) error
	publishCreateSchemaMutex       sync.RWMutex
	publishCreateSchemaArgsForCall []struct {
		arg1 context.Context
		arg2 *protos.Schema
	}
	publishCreateSchemaReturns struct {
		result1 error
	}
	publishCreateSchemaReturnsOnCall map[int]struct {
		result1 error
	}
	PublishCreateServiceStub        func(context.Context, *protos.Service) error
	publishCreateServiceMutex       sync.RWMutex
	publishCreateServiceArgsForCall []struct {
		arg1 context.Context
		arg2 *protos.Service
	}
	publishCreateServiceReturns struct {
		result1 error
	}
	publishCreateServiceReturnsOnCall map[int]struct {
		result1 error
	}
	PublishCreateValidationStub        func(context.Context, *common.Validation) error
	publishCreateValidationMutex       sync.RWMutex
	publishCreateValidationArgsForCall []struct {
		arg1 context.Context
		arg2 *common.Validation
	}
	publishCreateValidationReturns struct {
		result1 error
	}
	publishCreateValidationReturnsOnCall map[int]struct {
		result1 error
	}
	PublishDeleteCompositeStub        func(context.Context, *opts.Composite) error
	publishDeleteCompositeMutex       sync.RWMutex
	publishDeleteCompositeArgsForCall []struct {
		arg1 context.Context
		arg2 *opts.Composite
	}
	publishDeleteCompositeReturns struct {
		result1 error
	}
	publishDeleteCompositeReturnsOnCall map[int]struct {
		result1 error
	}
	PublishDeleteConnectionStub        func(context.Context, *opts.ConnectionOptions) error
	publishDeleteConnectionMutex       sync.RWMutex
	publishDeleteConnectionArgsForCall []struct {
		arg1 context.Context
		arg2 *opts.ConnectionOptions
	}
	publishDeleteConnectionReturns struct {
		result1 error
	}
	publishDeleteConnectionReturnsOnCall map[int]struct {
		result1 error
	}
	PublishDeleteDynamicStub        func(context.Context, *opts.DynamicOptions) error
	publishDeleteDynamicMutex       sync.RWMutex
	publishDeleteDynamicArgsForCall []struct {
		arg1 context.Context
		arg2 *opts.DynamicOptions
	}
	publishDeleteDynamicReturns struct {
		result1 error
	}
	publishDeleteDynamicReturnsOnCall map[int]struct {
		result1 error
	}
	PublishDeleteReadStub        func(context.Context, *opts.ReadOptions) error
	publishDeleteReadMutex       sync.RWMutex
	publishDeleteReadArgsForCall []struct {
		arg1 context.Context
		arg2 *opts.ReadOptions
	}
	publishDeleteReadReturns struct {
		result1 error
	}
	publishDeleteReadReturnsOnCall map[int]struct {
		result1 error
	}
	PublishDeleteRelayStub        func(context.Context, *opts.RelayOptions) error
	publishDeleteRelayMutex       sync.RWMutex
	publishDeleteRelayArgsForCall []struct {
		arg1 context.Context
		arg2 *opts.RelayOptions
	}
	publishDeleteRelayReturns struct {
		result1 error
	}
	publishDeleteRelayReturnsOnCall map[int]struct {
		result1 error
	}
	PublishDeleteSchemaStub        func(context.Context, *protos.Schema) error
	publishDeleteSchemaMutex       sync.RWMutex
	publishDeleteSchemaArgsForCall []struct {
		arg1 context.Context
		arg2 *protos.Schema
	}
	publishDeleteSchemaReturns struct {
		result1 error
	}
	publishDeleteSchemaReturnsOnCall map[int]struct {
		result1 error
	}
	PublishDeleteServiceStub        func(context.Context, *protos.Service) error
	publishDeleteServiceMutex       sync.RWMutex
	publishDeleteServiceArgsForCall []struct {
		arg1 context.Context
		arg2 *protos.Service
	}
	publishDeleteServiceReturns struct {
		result1 error
	}
	publishDeleteServiceReturnsOnCall map[int]struct {
		result1 error
	}
	PublishDeleteValidationStub        func(context.Context, *common.Validation) error
	publishDeleteValidationMutex       sync.RWMutex
	publishDeleteValidationArgsForCall []struct {
		arg1 context.Context
		arg2 *common.Validation
	}
	publishDeleteValidationReturns struct {
		result1 error
	}
	publishDeleteValidationReturnsOnCall map[int]struct {
		result1 error
	}
	PublishResumeDynamicStub        func(context.Context, *opts.DynamicOptions) error
	publishResumeDynamicMutex       sync.RWMutex
	publishResumeDynamicArgsForCall []struct {
		arg1 context.Context
		arg2 *opts.DynamicOptions
	}
	publishResumeDynamicReturns struct {
		result1 error
	}
	publishResumeDynamicReturnsOnCall map[int]struct {
		result1 error
	}
	PublishResumeRelayStub        func(context.Context, *opts.RelayOptions) error
	publishResumeRelayMutex       sync.RWMutex
	publishResumeRelayArgsForCall []struct {
		arg1 context.Context
		arg2 *opts.RelayOptions
	}
	publishResumeRelayReturns struct {
		result1 error
	}
	publishResumeRelayReturnsOnCall map[int]struct {
		result1 error
	}
	PublishStopDynamicStub        func(context.Context, *opts.DynamicOptions) error
	publishStopDynamicMutex       sync.RWMutex
	publishStopDynamicArgsForCall []struct {
		arg1 context.Context
		arg2 *opts.DynamicOptions
	}
	publishStopDynamicReturns struct {
		result1 error
	}
	publishStopDynamicReturnsOnCall map[int]struct {
		result1 error
	}
	PublishStopRelayStub        func(context.Context, *opts.RelayOptions) error
	publishStopRelayMutex       sync.RWMutex
	publishStopRelayArgsForCall []struct {
		arg1 context.Context
		arg2 *opts.RelayOptions
	}
	publishStopRelayReturns struct {
		result1 error
	}
	publishStopRelayReturnsOnCall map[int]struct {
		result1 error
	}
	PublishUpdateCompositeStub        func(context.Context, *opts.Composite) error
	publishUpdateCompositeMutex       sync.RWMutex
	publishUpdateCompositeArgsForCall []struct {
		arg1 context.Context
		arg2 *opts.Composite
	}
	publishUpdateCompositeReturns struct {
		result1 error
	}
	publishUpdateCompositeReturnsOnCall map[int]struct {
		result1 error
	}
	PublishUpdateConnectionStub        func(context.Context, *opts.ConnectionOptions) error
	publishUpdateConnectionMutex       sync.RWMutex
	publishUpdateConnectionArgsForCall []struct {
		arg1 context.Context
		arg2 *opts.ConnectionOptions
	}
	publishUpdateConnectionReturns struct {
		result1 error
	}
	publishUpdateConnectionReturnsOnCall map[int]struct {
		result1 error
	}
	PublishUpdateDynamicStub        func(context.Context, *opts.DynamicOptions) error
	publishUpdateDynamicMutex       sync.RWMutex
	publishUpdateDynamicArgsForCall []struct {
		arg1 context.Context
		arg2 *opts.DynamicOptions
	}
	publishUpdateDynamicReturns struct {
		result1 error
	}
	publishUpdateDynamicReturnsOnCall map[int]struct {
		result1 error
	}
	PublishUpdateRelayStub        func(context.Context, *opts.RelayOptions) error
	publishUpdateRelayMutex       sync.RWMutex
	publishUpdateRelayArgsForCall []struct {
		arg1 context.Context
		arg2 *opts.RelayOptions
	}
	publishUpdateRelayReturns struct {
		result1 error
	}
	publishUpdateRelayReturnsOnCall map[int]struct {
		result1 error
	}
	PublishUpdateSchemaStub        func(context.Context, *protos.Schema) error
	publishUpdateSchemaMutex       sync.RWMutex
	publishUpdateSchemaArgsForCall []struct {
		arg1 context.Context
		arg2 *protos.Schema
	}
	publishUpdateSchemaReturns struct {
		result1 error
	}
	publishUpdateSchemaReturnsOnCall map[int]struct {
		result1 error
	}
	PublishUpdateServiceStub        func(context.Context, *protos.Service) error
	publishUpdateServiceMutex       sync.RWMutex
	publishUpdateServiceArgsForCall []struct {
		arg1 context.Context
		arg2 *protos.Service
	}
	publishUpdateServiceReturns struct {
		result1 error
	}
	publishUpdateServiceReturnsOnCall map[int]struct {
		result1 error
	}
	PublishUpdateValidationStub        func(context.Context, *common.Validation) error
	publishUpdateValidationMutex       sync.RWMutex
	publishUpdateValidationArgsForCall []struct {
		arg1 context.Context
		arg2 *common.Validation
	}
	publishUpdateValidationReturns struct {
		result1 error
	}
	publishUpdateValidationReturnsOnCall map[int]struct {
		result1 error
	}
	PutStub        func(context.Context, string, string, ...clientv3.OpOption) (*clientv3.PutResponse, error)
	putMutex       sync.RWMutex
	putArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 []clientv3.OpOption
	}
	putReturns struct {
		result1 *clientv3.PutResponse
		result2 error
	}
	putReturnsOnCall map[int]struct {
		result1 *clientv3.PutResponse
		result2 error
	}
	PutWithTTLStub        func(context.Context, string, string, time.Duration) (*clientv3.PutResponse, error)
	putWithTTLMutex       sync.RWMutex
	putWithTTLArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 time.Duration
	}
	putWithTTLReturns struct {
		result1 *clientv3.PutResponse
		result2 error
	}
	putWithTTLReturnsOnCall map[int]struct {
		result1 *clientv3.PutResponse
		result2 error
	}
	SaveConfigStub        func(context.Context, *config.Config) error
	saveConfigMutex       sync.RWMutex
	saveConfigArgsForCall []struct {
		arg1 context.Context
		arg2 *config.Config
	}
	saveConfigReturns struct {
		result1 error
	}
	saveConfigReturnsOnCall map[int]struct {
		result1 error
	}
	ShutdownStub        func(bool) error
	shutdownMutex       sync.RWMutex
	shutdownArgsForCall []struct {
		arg1 bool
	}
	shutdownReturns struct {
		result1 error
	}
	shutdownReturnsOnCall map[int]struct {
		result1 error
	}
	StartStub        func(context.Context) error
	startMutex       sync.RWMutex
	startArgsForCall []struct {
		arg1 context.Context
	}
	startReturns struct {
		result1 error
	}
	startReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeIEtcd) Broadcast(arg1 context.Context, arg2 *etcd.Message) error {
	fake.broadcastMutex.Lock()
	ret, specificReturn := fake.broadcastReturnsOnCall[len(fake.broadcastArgsForCall)]
	fake.broadcastArgsForCall = append(fake.broadcastArgsForCall, struct {
		arg1 context.Context
		arg2 *etcd.Message
	}{arg1, arg2})
	stub := fake.BroadcastStub
	fakeReturns := fake.broadcastReturns
	fake.recordInvocation("Broadcast", []interface{}{arg1, arg2})
	fake.broadcastMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) BroadcastCallCount() int {
	fake.broadcastMutex.RLock()
	defer fake.broadcastMutex.RUnlock()
	return len(fake.broadcastArgsForCall)
}

func (fake *FakeIEtcd) BroadcastCalls(stub func(context.Context, *etcd.Message) error) {
	fake.broadcastMutex.Lock()
	defer fake.broadcastMutex.Unlock()
	fake.BroadcastStub = stub
}

func (fake *FakeIEtcd) BroadcastArgsForCall(i int) (context.Context, *etcd.Message) {
	fake.broadcastMutex.RLock()
	defer fake.broadcastMutex.RUnlock()
	argsForCall := fake.broadcastArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIEtcd) BroadcastReturns(result1 error) {
	fake.broadcastMutex.Lock()
	defer fake.broadcastMutex.Unlock()
	fake.BroadcastStub = nil
	fake.broadcastReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) BroadcastReturnsOnCall(i int, result1 error) {
	fake.broadcastMutex.Lock()
	defer fake.broadcastMutex.Unlock()
	fake.BroadcastStub = nil
	if fake.broadcastReturnsOnCall == nil {
		fake.broadcastReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.broadcastReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) Client() *clientv3.Client {
	fake.clientMutex.Lock()
	ret, specificReturn := fake.clientReturnsOnCall[len(fake.clientArgsForCall)]
	fake.clientArgsForCall = append(fake.clientArgsForCall, struct {
	}{})
	stub := fake.ClientStub
	fakeReturns := fake.clientReturns
	fake.recordInvocation("Client", []interface{}{})
	fake.clientMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) ClientCallCount() int {
	fake.clientMutex.RLock()
	defer fake.clientMutex.RUnlock()
	return len(fake.clientArgsForCall)
}

func (fake *FakeIEtcd) ClientCalls(stub func() *clientv3.Client) {
	fake.clientMutex.Lock()
	defer fake.clientMutex.Unlock()
	fake.ClientStub = stub
}

func (fake *FakeIEtcd) ClientReturns(result1 *clientv3.Client) {
	fake.clientMutex.Lock()
	defer fake.clientMutex.Unlock()
	fake.ClientStub = nil
	fake.clientReturns = struct {
		result1 *clientv3.Client
	}{result1}
}

func (fake *FakeIEtcd) ClientReturnsOnCall(i int, result1 *clientv3.Client) {
	fake.clientMutex.Lock()
	defer fake.clientMutex.Unlock()
	fake.ClientStub = nil
	if fake.clientReturnsOnCall == nil {
		fake.clientReturnsOnCall = make(map[int]struct {
			result1 *clientv3.Client
		})
	}
	fake.clientReturnsOnCall[i] = struct {
		result1 *clientv3.Client
	}{result1}
}

func (fake *FakeIEtcd) Delete(arg1 context.Context, arg2 string, arg3 ...clientv3.OpOption) (*clientv3.DeleteResponse, error) {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []clientv3.OpOption
	}{arg1, arg2, arg3})
	stub := fake.DeleteStub
	fakeReturns := fake.deleteReturns
	fake.recordInvocation("Delete", []interface{}{arg1, arg2, arg3})
	fake.deleteMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIEtcd) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeIEtcd) DeleteCalls(stub func(context.Context, string, ...clientv3.OpOption) (*clientv3.DeleteResponse, error)) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = stub
}

func (fake *FakeIEtcd) DeleteArgsForCall(i int) (context.Context, string, []clientv3.OpOption) {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	argsForCall := fake.deleteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeIEtcd) DeleteReturns(result1 *clientv3.DeleteResponse, result2 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 *clientv3.DeleteResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeIEtcd) DeleteReturnsOnCall(i int, result1 *clientv3.DeleteResponse, result2 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 *clientv3.DeleteResponse
			result2 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 *clientv3.DeleteResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeIEtcd) Direct(arg1 context.Context, arg2 string, arg3 *etcd.Message) error {
	fake.directMutex.Lock()
	ret, specificReturn := fake.directReturnsOnCall[len(fake.directArgsForCall)]
	fake.directArgsForCall = append(fake.directArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 *etcd.Message
	}{arg1, arg2, arg3})
	stub := fake.DirectStub
	fakeReturns := fake.directReturns
	fake.recordInvocation("Direct", []interface{}{arg1, arg2, arg3})
	fake.directMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) DirectCallCount() int {
	fake.directMutex.RLock()
	defer fake.directMutex.RUnlock()
	return len(fake.directArgsForCall)
}

func (fake *FakeIEtcd) DirectCalls(stub func(context.Context, string, *etcd.Message) error) {
	fake.directMutex.Lock()
	defer fake.directMutex.Unlock()
	fake.DirectStub = stub
}

func (fake *FakeIEtcd) DirectArgsForCall(i int) (context.Context, string, *etcd.Message) {
	fake.directMutex.RLock()
	defer fake.directMutex.RUnlock()
	argsForCall := fake.directArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeIEtcd) DirectReturns(result1 error) {
	fake.directMutex.Lock()
	defer fake.directMutex.Unlock()
	fake.DirectStub = nil
	fake.directReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) DirectReturnsOnCall(i int, result1 error) {
	fake.directMutex.Lock()
	defer fake.directMutex.Unlock()
	fake.DirectStub = nil
	if fake.directReturnsOnCall == nil {
		fake.directReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.directReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) Get(arg1 context.Context, arg2 string, arg3 ...clientv3.OpOption) (*clientv3.GetResponse, error) {
	fake.getMutex.Lock()
	ret, specificReturn := fake.getReturnsOnCall[len(fake.getArgsForCall)]
	fake.getArgsForCall = append(fake.getArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []clientv3.OpOption
	}{arg1, arg2, arg3})
	stub := fake.GetStub
	fakeReturns := fake.getReturns
	fake.recordInvocation("Get", []interface{}{arg1, arg2, arg3})
	fake.getMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIEtcd) GetCallCount() int {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return len(fake.getArgsForCall)
}

func (fake *FakeIEtcd) GetCalls(stub func(context.Context, string, ...clientv3.OpOption) (*clientv3.GetResponse, error)) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = stub
}

func (fake *FakeIEtcd) GetArgsForCall(i int) (context.Context, string, []clientv3.OpOption) {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	argsForCall := fake.getArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeIEtcd) GetReturns(result1 *clientv3.GetResponse, result2 error) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	fake.getReturns = struct {
		result1 *clientv3.GetResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeIEtcd) GetReturnsOnCall(i int, result1 *clientv3.GetResponse, result2 error) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	if fake.getReturnsOnCall == nil {
		fake.getReturnsOnCall = make(map[int]struct {
			result1 *clientv3.GetResponse
			result2 error
		})
	}
	fake.getReturnsOnCall[i] = struct {
		result1 *clientv3.GetResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeIEtcd) GrantLease(arg1 context.Context, arg2 int64) (*clientv3.LeaseGrantResponse, error) {
	fake.grantLeaseMutex.Lock()
	ret, specificReturn := fake.grantLeaseReturnsOnCall[len(fake.grantLeaseArgsForCall)]
	fake.grantLeaseArgsForCall = append(fake.grantLeaseArgsForCall, struct {
		arg1 context.Context
		arg2 int64
	}{arg1, arg2})
	stub := fake.GrantLeaseStub
	fakeReturns := fake.grantLeaseReturns
	fake.recordInvocation("GrantLease", []interface{}{arg1, arg2})
	fake.grantLeaseMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIEtcd) GrantLeaseCallCount() int {
	fake.grantLeaseMutex.RLock()
	defer fake.grantLeaseMutex.RUnlock()
	return len(fake.grantLeaseArgsForCall)
}

func (fake *FakeIEtcd) GrantLeaseCalls(stub func(context.Context, int64) (*clientv3.LeaseGrantResponse, error)) {
	fake.grantLeaseMutex.Lock()
	defer fake.grantLeaseMutex.Unlock()
	fake.GrantLeaseStub = stub
}

func (fake *FakeIEtcd) GrantLeaseArgsForCall(i int) (context.Context, int64) {
	fake.grantLeaseMutex.RLock()
	defer fake.grantLeaseMutex.RUnlock()
	argsForCall := fake.grantLeaseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIEtcd) GrantLeaseReturns(result1 *clientv3.LeaseGrantResponse, result2 error) {
	fake.grantLeaseMutex.Lock()
	defer fake.grantLeaseMutex.Unlock()
	fake.GrantLeaseStub = nil
	fake.grantLeaseReturns = struct {
		result1 *clientv3.LeaseGrantResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeIEtcd) GrantLeaseReturnsOnCall(i int, result1 *clientv3.LeaseGrantResponse, result2 error) {
	fake.grantLeaseMutex.Lock()
	defer fake.grantLeaseMutex.Unlock()
	fake.GrantLeaseStub = nil
	if fake.grantLeaseReturnsOnCall == nil {
		fake.grantLeaseReturnsOnCall = make(map[int]struct {
			result1 *clientv3.LeaseGrantResponse
			result2 error
		})
	}
	fake.grantLeaseReturnsOnCall[i] = struct {
		result1 *clientv3.LeaseGrantResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeIEtcd) PublishConfigUpdate(arg1 context.Context, arg2 *etcd.MessageUpdateConfig) error {
	fake.publishConfigUpdateMutex.Lock()
	ret, specificReturn := fake.publishConfigUpdateReturnsOnCall[len(fake.publishConfigUpdateArgsForCall)]
	fake.publishConfigUpdateArgsForCall = append(fake.publishConfigUpdateArgsForCall, struct {
		arg1 context.Context
		arg2 *etcd.MessageUpdateConfig
	}{arg1, arg2})
	stub := fake.PublishConfigUpdateStub
	fakeReturns := fake.publishConfigUpdateReturns
	fake.recordInvocation("PublishConfigUpdate", []interface{}{arg1, arg2})
	fake.publishConfigUpdateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) PublishConfigUpdateCallCount() int {
	fake.publishConfigUpdateMutex.RLock()
	defer fake.publishConfigUpdateMutex.RUnlock()
	return len(fake.publishConfigUpdateArgsForCall)
}

func (fake *FakeIEtcd) PublishConfigUpdateCalls(stub func(context.Context, *etcd.MessageUpdateConfig) error) {
	fake.publishConfigUpdateMutex.Lock()
	defer fake.publishConfigUpdateMutex.Unlock()
	fake.PublishConfigUpdateStub = stub
}

func (fake *FakeIEtcd) PublishConfigUpdateArgsForCall(i int) (context.Context, *etcd.MessageUpdateConfig) {
	fake.publishConfigUpdateMutex.RLock()
	defer fake.publishConfigUpdateMutex.RUnlock()
	argsForCall := fake.publishConfigUpdateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIEtcd) PublishConfigUpdateReturns(result1 error) {
	fake.publishConfigUpdateMutex.Lock()
	defer fake.publishConfigUpdateMutex.Unlock()
	fake.PublishConfigUpdateStub = nil
	fake.publishConfigUpdateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishConfigUpdateReturnsOnCall(i int, result1 error) {
	fake.publishConfigUpdateMutex.Lock()
	defer fake.publishConfigUpdateMutex.Unlock()
	fake.PublishConfigUpdateStub = nil
	if fake.publishConfigUpdateReturnsOnCall == nil {
		fake.publishConfigUpdateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.publishConfigUpdateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishCreateComposite(arg1 context.Context, arg2 *opts.Composite) error {
	fake.publishCreateCompositeMutex.Lock()
	ret, specificReturn := fake.publishCreateCompositeReturnsOnCall[len(fake.publishCreateCompositeArgsForCall)]
	fake.publishCreateCompositeArgsForCall = append(fake.publishCreateCompositeArgsForCall, struct {
		arg1 context.Context
		arg2 *opts.Composite
	}{arg1, arg2})
	stub := fake.PublishCreateCompositeStub
	fakeReturns := fake.publishCreateCompositeReturns
	fake.recordInvocation("PublishCreateComposite", []interface{}{arg1, arg2})
	fake.publishCreateCompositeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) PublishCreateCompositeCallCount() int {
	fake.publishCreateCompositeMutex.RLock()
	defer fake.publishCreateCompositeMutex.RUnlock()
	return len(fake.publishCreateCompositeArgsForCall)
}

func (fake *FakeIEtcd) PublishCreateCompositeCalls(stub func(context.Context, *opts.Composite) error) {
	fake.publishCreateCompositeMutex.Lock()
	defer fake.publishCreateCompositeMutex.Unlock()
	fake.PublishCreateCompositeStub = stub
}

func (fake *FakeIEtcd) PublishCreateCompositeArgsForCall(i int) (context.Context, *opts.Composite) {
	fake.publishCreateCompositeMutex.RLock()
	defer fake.publishCreateCompositeMutex.RUnlock()
	argsForCall := fake.publishCreateCompositeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIEtcd) PublishCreateCompositeReturns(result1 error) {
	fake.publishCreateCompositeMutex.Lock()
	defer fake.publishCreateCompositeMutex.Unlock()
	fake.PublishCreateCompositeStub = nil
	fake.publishCreateCompositeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishCreateCompositeReturnsOnCall(i int, result1 error) {
	fake.publishCreateCompositeMutex.Lock()
	defer fake.publishCreateCompositeMutex.Unlock()
	fake.PublishCreateCompositeStub = nil
	if fake.publishCreateCompositeReturnsOnCall == nil {
		fake.publishCreateCompositeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.publishCreateCompositeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishCreateConnection(arg1 context.Context, arg2 *opts.ConnectionOptions) error {
	fake.publishCreateConnectionMutex.Lock()
	ret, specificReturn := fake.publishCreateConnectionReturnsOnCall[len(fake.publishCreateConnectionArgsForCall)]
	fake.publishCreateConnectionArgsForCall = append(fake.publishCreateConnectionArgsForCall, struct {
		arg1 context.Context
		arg2 *opts.ConnectionOptions
	}{arg1, arg2})
	stub := fake.PublishCreateConnectionStub
	fakeReturns := fake.publishCreateConnectionReturns
	fake.recordInvocation("PublishCreateConnection", []interface{}{arg1, arg2})
	fake.publishCreateConnectionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) PublishCreateConnectionCallCount() int {
	fake.publishCreateConnectionMutex.RLock()
	defer fake.publishCreateConnectionMutex.RUnlock()
	return len(fake.publishCreateConnectionArgsForCall)
}

func (fake *FakeIEtcd) PublishCreateConnectionCalls(stub func(context.Context, *opts.ConnectionOptions) error) {
	fake.publishCreateConnectionMutex.Lock()
	defer fake.publishCreateConnectionMutex.Unlock()
	fake.PublishCreateConnectionStub = stub
}

func (fake *FakeIEtcd) PublishCreateConnectionArgsForCall(i int) (context.Context, *opts.ConnectionOptions) {
	fake.publishCreateConnectionMutex.RLock()
	defer fake.publishCreateConnectionMutex.RUnlock()
	argsForCall := fake.publishCreateConnectionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIEtcd) PublishCreateConnectionReturns(result1 error) {
	fake.publishCreateConnectionMutex.Lock()
	defer fake.publishCreateConnectionMutex.Unlock()
	fake.PublishCreateConnectionStub = nil
	fake.publishCreateConnectionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishCreateConnectionReturnsOnCall(i int, result1 error) {
	fake.publishCreateConnectionMutex.Lock()
	defer fake.publishCreateConnectionMutex.Unlock()
	fake.PublishCreateConnectionStub = nil
	if fake.publishCreateConnectionReturnsOnCall == nil {
		fake.publishCreateConnectionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.publishCreateConnectionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishCreateDynamic(arg1 context.Context, arg2 *opts.DynamicOptions) error {
	fake.publishCreateDynamicMutex.Lock()
	ret, specificReturn := fake.publishCreateDynamicReturnsOnCall[len(fake.publishCreateDynamicArgsForCall)]
	fake.publishCreateDynamicArgsForCall = append(fake.publishCreateDynamicArgsForCall, struct {
		arg1 context.Context
		arg2 *opts.DynamicOptions
	}{arg1, arg2})
	stub := fake.PublishCreateDynamicStub
	fakeReturns := fake.publishCreateDynamicReturns
	fake.recordInvocation("PublishCreateDynamic", []interface{}{arg1, arg2})
	fake.publishCreateDynamicMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) PublishCreateDynamicCallCount() int {
	fake.publishCreateDynamicMutex.RLock()
	defer fake.publishCreateDynamicMutex.RUnlock()
	return len(fake.publishCreateDynamicArgsForCall)
}

func (fake *FakeIEtcd) PublishCreateDynamicCalls(stub func(context.Context, *opts.DynamicOptions) error) {
	fake.publishCreateDynamicMutex.Lock()
	defer fake.publishCreateDynamicMutex.Unlock()
	fake.PublishCreateDynamicStub = stub
}

func (fake *FakeIEtcd) PublishCreateDynamicArgsForCall(i int) (context.Context, *opts.DynamicOptions) {
	fake.publishCreateDynamicMutex.RLock()
	defer fake.publishCreateDynamicMutex.RUnlock()
	argsForCall := fake.publishCreateDynamicArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIEtcd) PublishCreateDynamicReturns(result1 error) {
	fake.publishCreateDynamicMutex.Lock()
	defer fake.publishCreateDynamicMutex.Unlock()
	fake.PublishCreateDynamicStub = nil
	fake.publishCreateDynamicReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishCreateDynamicReturnsOnCall(i int, result1 error) {
	fake.publishCreateDynamicMutex.Lock()
	defer fake.publishCreateDynamicMutex.Unlock()
	fake.PublishCreateDynamicStub = nil
	if fake.publishCreateDynamicReturnsOnCall == nil {
		fake.publishCreateDynamicReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.publishCreateDynamicReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishCreateRead(arg1 context.Context, arg2 *opts.ReadOptions) error {
	fake.publishCreateReadMutex.Lock()
	ret, specificReturn := fake.publishCreateReadReturnsOnCall[len(fake.publishCreateReadArgsForCall)]
	fake.publishCreateReadArgsForCall = append(fake.publishCreateReadArgsForCall, struct {
		arg1 context.Context
		arg2 *opts.ReadOptions
	}{arg1, arg2})
	stub := fake.PublishCreateReadStub
	fakeReturns := fake.publishCreateReadReturns
	fake.recordInvocation("PublishCreateRead", []interface{}{arg1, arg2})
	fake.publishCreateReadMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) PublishCreateReadCallCount() int {
	fake.publishCreateReadMutex.RLock()
	defer fake.publishCreateReadMutex.RUnlock()
	return len(fake.publishCreateReadArgsForCall)
}

func (fake *FakeIEtcd) PublishCreateReadCalls(stub func(context.Context, *opts.ReadOptions) error) {
	fake.publishCreateReadMutex.Lock()
	defer fake.publishCreateReadMutex.Unlock()
	fake.PublishCreateReadStub = stub
}

func (fake *FakeIEtcd) PublishCreateReadArgsForCall(i int) (context.Context, *opts.ReadOptions) {
	fake.publishCreateReadMutex.RLock()
	defer fake.publishCreateReadMutex.RUnlock()
	argsForCall := fake.publishCreateReadArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIEtcd) PublishCreateReadReturns(result1 error) {
	fake.publishCreateReadMutex.Lock()
	defer fake.publishCreateReadMutex.Unlock()
	fake.PublishCreateReadStub = nil
	fake.publishCreateReadReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishCreateReadReturnsOnCall(i int, result1 error) {
	fake.publishCreateReadMutex.Lock()
	defer fake.publishCreateReadMutex.Unlock()
	fake.PublishCreateReadStub = nil
	if fake.publishCreateReadReturnsOnCall == nil {
		fake.publishCreateReadReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.publishCreateReadReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishCreateRelay(arg1 context.Context, arg2 *opts.RelayOptions) error {
	fake.publishCreateRelayMutex.Lock()
	ret, specificReturn := fake.publishCreateRelayReturnsOnCall[len(fake.publishCreateRelayArgsForCall)]
	fake.publishCreateRelayArgsForCall = append(fake.publishCreateRelayArgsForCall, struct {
		arg1 context.Context
		arg2 *opts.RelayOptions
	}{arg1, arg2})
	stub := fake.PublishCreateRelayStub
	fakeReturns := fake.publishCreateRelayReturns
	fake.recordInvocation("PublishCreateRelay", []interface{}{arg1, arg2})
	fake.publishCreateRelayMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) PublishCreateRelayCallCount() int {
	fake.publishCreateRelayMutex.RLock()
	defer fake.publishCreateRelayMutex.RUnlock()
	return len(fake.publishCreateRelayArgsForCall)
}

func (fake *FakeIEtcd) PublishCreateRelayCalls(stub func(context.Context, *opts.RelayOptions) error) {
	fake.publishCreateRelayMutex.Lock()
	defer fake.publishCreateRelayMutex.Unlock()
	fake.PublishCreateRelayStub = stub
}

func (fake *FakeIEtcd) PublishCreateRelayArgsForCall(i int) (context.Context, *opts.RelayOptions) {
	fake.publishCreateRelayMutex.RLock()
	defer fake.publishCreateRelayMutex.RUnlock()
	argsForCall := fake.publishCreateRelayArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIEtcd) PublishCreateRelayReturns(result1 error) {
	fake.publishCreateRelayMutex.Lock()
	defer fake.publishCreateRelayMutex.Unlock()
	fake.PublishCreateRelayStub = nil
	fake.publishCreateRelayReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishCreateRelayReturnsOnCall(i int, result1 error) {
	fake.publishCreateRelayMutex.Lock()
	defer fake.publishCreateRelayMutex.Unlock()
	fake.PublishCreateRelayStub = nil
	if fake.publishCreateRelayReturnsOnCall == nil {
		fake.publishCreateRelayReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.publishCreateRelayReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishCreateSchema(arg1 context.Context, arg2 *protos.Schema) error {
	fake.publishCreateSchemaMutex.Lock()
	ret, specificReturn := fake.publishCreateSchemaReturnsOnCall[len(fake.publishCreateSchemaArgsForCall)]
	fake.publishCreateSchemaArgsForCall = append(fake.publishCreateSchemaArgsForCall, struct {
		arg1 context.Context
		arg2 *protos.Schema
	}{arg1, arg2})
	stub := fake.PublishCreateSchemaStub
	fakeReturns := fake.publishCreateSchemaReturns
	fake.recordInvocation("PublishCreateSchema", []interface{}{arg1, arg2})
	fake.publishCreateSchemaMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) PublishCreateSchemaCallCount() int {
	fake.publishCreateSchemaMutex.RLock()
	defer fake.publishCreateSchemaMutex.RUnlock()
	return len(fake.publishCreateSchemaArgsForCall)
}

func (fake *FakeIEtcd) PublishCreateSchemaCalls(stub func(context.Context, *protos.Schema) error) {
	fake.publishCreateSchemaMutex.Lock()
	defer fake.publishCreateSchemaMutex.Unlock()
	fake.PublishCreateSchemaStub = stub
}

func (fake *FakeIEtcd) PublishCreateSchemaArgsForCall(i int) (context.Context, *protos.Schema) {
	fake.publishCreateSchemaMutex.RLock()
	defer fake.publishCreateSchemaMutex.RUnlock()
	argsForCall := fake.publishCreateSchemaArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIEtcd) PublishCreateSchemaReturns(result1 error) {
	fake.publishCreateSchemaMutex.Lock()
	defer fake.publishCreateSchemaMutex.Unlock()
	fake.PublishCreateSchemaStub = nil
	fake.publishCreateSchemaReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishCreateSchemaReturnsOnCall(i int, result1 error) {
	fake.publishCreateSchemaMutex.Lock()
	defer fake.publishCreateSchemaMutex.Unlock()
	fake.PublishCreateSchemaStub = nil
	if fake.publishCreateSchemaReturnsOnCall == nil {
		fake.publishCreateSchemaReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.publishCreateSchemaReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishCreateService(arg1 context.Context, arg2 *protos.Service) error {
	fake.publishCreateServiceMutex.Lock()
	ret, specificReturn := fake.publishCreateServiceReturnsOnCall[len(fake.publishCreateServiceArgsForCall)]
	fake.publishCreateServiceArgsForCall = append(fake.publishCreateServiceArgsForCall, struct {
		arg1 context.Context
		arg2 *protos.Service
	}{arg1, arg2})
	stub := fake.PublishCreateServiceStub
	fakeReturns := fake.publishCreateServiceReturns
	fake.recordInvocation("PublishCreateService", []interface{}{arg1, arg2})
	fake.publishCreateServiceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) PublishCreateServiceCallCount() int {
	fake.publishCreateServiceMutex.RLock()
	defer fake.publishCreateServiceMutex.RUnlock()
	return len(fake.publishCreateServiceArgsForCall)
}

func (fake *FakeIEtcd) PublishCreateServiceCalls(stub func(context.Context, *protos.Service) error) {
	fake.publishCreateServiceMutex.Lock()
	defer fake.publishCreateServiceMutex.Unlock()
	fake.PublishCreateServiceStub = stub
}

func (fake *FakeIEtcd) PublishCreateServiceArgsForCall(i int) (context.Context, *protos.Service) {
	fake.publishCreateServiceMutex.RLock()
	defer fake.publishCreateServiceMutex.RUnlock()
	argsForCall := fake.publishCreateServiceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIEtcd) PublishCreateServiceReturns(result1 error) {
	fake.publishCreateServiceMutex.Lock()
	defer fake.publishCreateServiceMutex.Unlock()
	fake.PublishCreateServiceStub = nil
	fake.publishCreateServiceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishCreateServiceReturnsOnCall(i int, result1 error) {
	fake.publishCreateServiceMutex.Lock()
	defer fake.publishCreateServiceMutex.Unlock()
	fake.PublishCreateServiceStub = nil
	if fake.publishCreateServiceReturnsOnCall == nil {
		fake.publishCreateServiceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.publishCreateServiceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishCreateValidation(arg1 context.Context, arg2 *common.Validation) error {
	fake.publishCreateValidationMutex.Lock()
	ret, specificReturn := fake.publishCreateValidationReturnsOnCall[len(fake.publishCreateValidationArgsForCall)]
	fake.publishCreateValidationArgsForCall = append(fake.publishCreateValidationArgsForCall, struct {
		arg1 context.Context
		arg2 *common.Validation
	}{arg1, arg2})
	stub := fake.PublishCreateValidationStub
	fakeReturns := fake.publishCreateValidationReturns
	fake.recordInvocation("PublishCreateValidation", []interface{}{arg1, arg2})
	fake.publishCreateValidationMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) PublishCreateValidationCallCount() int {
	fake.publishCreateValidationMutex.RLock()
	defer fake.publishCreateValidationMutex.RUnlock()
	return len(fake.publishCreateValidationArgsForCall)
}

func (fake *FakeIEtcd) PublishCreateValidationCalls(stub func(context.Context, *common.Validation) error) {
	fake.publishCreateValidationMutex.Lock()
	defer fake.publishCreateValidationMutex.Unlock()
	fake.PublishCreateValidationStub = stub
}

func (fake *FakeIEtcd) PublishCreateValidationArgsForCall(i int) (context.Context, *common.Validation) {
	fake.publishCreateValidationMutex.RLock()
	defer fake.publishCreateValidationMutex.RUnlock()
	argsForCall := fake.publishCreateValidationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIEtcd) PublishCreateValidationReturns(result1 error) {
	fake.publishCreateValidationMutex.Lock()
	defer fake.publishCreateValidationMutex.Unlock()
	fake.PublishCreateValidationStub = nil
	fake.publishCreateValidationReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishCreateValidationReturnsOnCall(i int, result1 error) {
	fake.publishCreateValidationMutex.Lock()
	defer fake.publishCreateValidationMutex.Unlock()
	fake.PublishCreateValidationStub = nil
	if fake.publishCreateValidationReturnsOnCall == nil {
		fake.publishCreateValidationReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.publishCreateValidationReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishDeleteComposite(arg1 context.Context, arg2 *opts.Composite) error {
	fake.publishDeleteCompositeMutex.Lock()
	ret, specificReturn := fake.publishDeleteCompositeReturnsOnCall[len(fake.publishDeleteCompositeArgsForCall)]
	fake.publishDeleteCompositeArgsForCall = append(fake.publishDeleteCompositeArgsForCall, struct {
		arg1 context.Context
		arg2 *opts.Composite
	}{arg1, arg2})
	stub := fake.PublishDeleteCompositeStub
	fakeReturns := fake.publishDeleteCompositeReturns
	fake.recordInvocation("PublishDeleteComposite", []interface{}{arg1, arg2})
	fake.publishDeleteCompositeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) PublishDeleteCompositeCallCount() int {
	fake.publishDeleteCompositeMutex.RLock()
	defer fake.publishDeleteCompositeMutex.RUnlock()
	return len(fake.publishDeleteCompositeArgsForCall)
}

func (fake *FakeIEtcd) PublishDeleteCompositeCalls(stub func(context.Context, *opts.Composite) error) {
	fake.publishDeleteCompositeMutex.Lock()
	defer fake.publishDeleteCompositeMutex.Unlock()
	fake.PublishDeleteCompositeStub = stub
}

func (fake *FakeIEtcd) PublishDeleteCompositeArgsForCall(i int) (context.Context, *opts.Composite) {
	fake.publishDeleteCompositeMutex.RLock()
	defer fake.publishDeleteCompositeMutex.RUnlock()
	argsForCall := fake.publishDeleteCompositeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIEtcd) PublishDeleteCompositeReturns(result1 error) {
	fake.publishDeleteCompositeMutex.Lock()
	defer fake.publishDeleteCompositeMutex.Unlock()
	fake.PublishDeleteCompositeStub = nil
	fake.publishDeleteCompositeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishDeleteCompositeReturnsOnCall(i int, result1 error) {
	fake.publishDeleteCompositeMutex.Lock()
	defer fake.publishDeleteCompositeMutex.Unlock()
	fake.PublishDeleteCompositeStub = nil
	if fake.publishDeleteCompositeReturnsOnCall == nil {
		fake.publishDeleteCompositeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.publishDeleteCompositeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishDeleteConnection(arg1 context.Context, arg2 *opts.ConnectionOptions) error {
	fake.publishDeleteConnectionMutex.Lock()
	ret, specificReturn := fake.publishDeleteConnectionReturnsOnCall[len(fake.publishDeleteConnectionArgsForCall)]
	fake.publishDeleteConnectionArgsForCall = append(fake.publishDeleteConnectionArgsForCall, struct {
		arg1 context.Context
		arg2 *opts.ConnectionOptions
	}{arg1, arg2})
	stub := fake.PublishDeleteConnectionStub
	fakeReturns := fake.publishDeleteConnectionReturns
	fake.recordInvocation("PublishDeleteConnection", []interface{}{arg1, arg2})
	fake.publishDeleteConnectionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) PublishDeleteConnectionCallCount() int {
	fake.publishDeleteConnectionMutex.RLock()
	defer fake.publishDeleteConnectionMutex.RUnlock()
	return len(fake.publishDeleteConnectionArgsForCall)
}

func (fake *FakeIEtcd) PublishDeleteConnectionCalls(stub func(context.Context, *opts.ConnectionOptions) error) {
	fake.publishDeleteConnectionMutex.Lock()
	defer fake.publishDeleteConnectionMutex.Unlock()
	fake.PublishDeleteConnectionStub = stub
}

func (fake *FakeIEtcd) PublishDeleteConnectionArgsForCall(i int) (context.Context, *opts.ConnectionOptions) {
	fake.publishDeleteConnectionMutex.RLock()
	defer fake.publishDeleteConnectionMutex.RUnlock()
	argsForCall := fake.publishDeleteConnectionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIEtcd) PublishDeleteConnectionReturns(result1 error) {
	fake.publishDeleteConnectionMutex.Lock()
	defer fake.publishDeleteConnectionMutex.Unlock()
	fake.PublishDeleteConnectionStub = nil
	fake.publishDeleteConnectionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishDeleteConnectionReturnsOnCall(i int, result1 error) {
	fake.publishDeleteConnectionMutex.Lock()
	defer fake.publishDeleteConnectionMutex.Unlock()
	fake.PublishDeleteConnectionStub = nil
	if fake.publishDeleteConnectionReturnsOnCall == nil {
		fake.publishDeleteConnectionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.publishDeleteConnectionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishDeleteDynamic(arg1 context.Context, arg2 *opts.DynamicOptions) error {
	fake.publishDeleteDynamicMutex.Lock()
	ret, specificReturn := fake.publishDeleteDynamicReturnsOnCall[len(fake.publishDeleteDynamicArgsForCall)]
	fake.publishDeleteDynamicArgsForCall = append(fake.publishDeleteDynamicArgsForCall, struct {
		arg1 context.Context
		arg2 *opts.DynamicOptions
	}{arg1, arg2})
	stub := fake.PublishDeleteDynamicStub
	fakeReturns := fake.publishDeleteDynamicReturns
	fake.recordInvocation("PublishDeleteDynamic", []interface{}{arg1, arg2})
	fake.publishDeleteDynamicMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) PublishDeleteDynamicCallCount() int {
	fake.publishDeleteDynamicMutex.RLock()
	defer fake.publishDeleteDynamicMutex.RUnlock()
	return len(fake.publishDeleteDynamicArgsForCall)
}

func (fake *FakeIEtcd) PublishDeleteDynamicCalls(stub func(context.Context, *opts.DynamicOptions) error) {
	fake.publishDeleteDynamicMutex.Lock()
	defer fake.publishDeleteDynamicMutex.Unlock()
	fake.PublishDeleteDynamicStub = stub
}

func (fake *FakeIEtcd) PublishDeleteDynamicArgsForCall(i int) (context.Context, *opts.DynamicOptions) {
	fake.publishDeleteDynamicMutex.RLock()
	defer fake.publishDeleteDynamicMutex.RUnlock()
	argsForCall := fake.publishDeleteDynamicArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIEtcd) PublishDeleteDynamicReturns(result1 error) {
	fake.publishDeleteDynamicMutex.Lock()
	defer fake.publishDeleteDynamicMutex.Unlock()
	fake.PublishDeleteDynamicStub = nil
	fake.publishDeleteDynamicReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishDeleteDynamicReturnsOnCall(i int, result1 error) {
	fake.publishDeleteDynamicMutex.Lock()
	defer fake.publishDeleteDynamicMutex.Unlock()
	fake.PublishDeleteDynamicStub = nil
	if fake.publishDeleteDynamicReturnsOnCall == nil {
		fake.publishDeleteDynamicReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.publishDeleteDynamicReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishDeleteRead(arg1 context.Context, arg2 *opts.ReadOptions) error {
	fake.publishDeleteReadMutex.Lock()
	ret, specificReturn := fake.publishDeleteReadReturnsOnCall[len(fake.publishDeleteReadArgsForCall)]
	fake.publishDeleteReadArgsForCall = append(fake.publishDeleteReadArgsForCall, struct {
		arg1 context.Context
		arg2 *opts.ReadOptions
	}{arg1, arg2})
	stub := fake.PublishDeleteReadStub
	fakeReturns := fake.publishDeleteReadReturns
	fake.recordInvocation("PublishDeleteRead", []interface{}{arg1, arg2})
	fake.publishDeleteReadMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) PublishDeleteReadCallCount() int {
	fake.publishDeleteReadMutex.RLock()
	defer fake.publishDeleteReadMutex.RUnlock()
	return len(fake.publishDeleteReadArgsForCall)
}

func (fake *FakeIEtcd) PublishDeleteReadCalls(stub func(context.Context, *opts.ReadOptions) error) {
	fake.publishDeleteReadMutex.Lock()
	defer fake.publishDeleteReadMutex.Unlock()
	fake.PublishDeleteReadStub = stub
}

func (fake *FakeIEtcd) PublishDeleteReadArgsForCall(i int) (context.Context, *opts.ReadOptions) {
	fake.publishDeleteReadMutex.RLock()
	defer fake.publishDeleteReadMutex.RUnlock()
	argsForCall := fake.publishDeleteReadArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIEtcd) PublishDeleteReadReturns(result1 error) {
	fake.publishDeleteReadMutex.Lock()
	defer fake.publishDeleteReadMutex.Unlock()
	fake.PublishDeleteReadStub = nil
	fake.publishDeleteReadReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishDeleteReadReturnsOnCall(i int, result1 error) {
	fake.publishDeleteReadMutex.Lock()
	defer fake.publishDeleteReadMutex.Unlock()
	fake.PublishDeleteReadStub = nil
	if fake.publishDeleteReadReturnsOnCall == nil {
		fake.publishDeleteReadReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.publishDeleteReadReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishDeleteRelay(arg1 context.Context, arg2 *opts.RelayOptions) error {
	fake.publishDeleteRelayMutex.Lock()
	ret, specificReturn := fake.publishDeleteRelayReturnsOnCall[len(fake.publishDeleteRelayArgsForCall)]
	fake.publishDeleteRelayArgsForCall = append(fake.publishDeleteRelayArgsForCall, struct {
		arg1 context.Context
		arg2 *opts.RelayOptions
	}{arg1, arg2})
	stub := fake.PublishDeleteRelayStub
	fakeReturns := fake.publishDeleteRelayReturns
	fake.recordInvocation("PublishDeleteRelay", []interface{}{arg1, arg2})
	fake.publishDeleteRelayMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) PublishDeleteRelayCallCount() int {
	fake.publishDeleteRelayMutex.RLock()
	defer fake.publishDeleteRelayMutex.RUnlock()
	return len(fake.publishDeleteRelayArgsForCall)
}

func (fake *FakeIEtcd) PublishDeleteRelayCalls(stub func(context.Context, *opts.RelayOptions) error) {
	fake.publishDeleteRelayMutex.Lock()
	defer fake.publishDeleteRelayMutex.Unlock()
	fake.PublishDeleteRelayStub = stub
}

func (fake *FakeIEtcd) PublishDeleteRelayArgsForCall(i int) (context.Context, *opts.RelayOptions) {
	fake.publishDeleteRelayMutex.RLock()
	defer fake.publishDeleteRelayMutex.RUnlock()
	argsForCall := fake.publishDeleteRelayArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIEtcd) PublishDeleteRelayReturns(result1 error) {
	fake.publishDeleteRelayMutex.Lock()
	defer fake.publishDeleteRelayMutex.Unlock()
	fake.PublishDeleteRelayStub = nil
	fake.publishDeleteRelayReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishDeleteRelayReturnsOnCall(i int, result1 error) {
	fake.publishDeleteRelayMutex.Lock()
	defer fake.publishDeleteRelayMutex.Unlock()
	fake.PublishDeleteRelayStub = nil
	if fake.publishDeleteRelayReturnsOnCall == nil {
		fake.publishDeleteRelayReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.publishDeleteRelayReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishDeleteSchema(arg1 context.Context, arg2 *protos.Schema) error {
	fake.publishDeleteSchemaMutex.Lock()
	ret, specificReturn := fake.publishDeleteSchemaReturnsOnCall[len(fake.publishDeleteSchemaArgsForCall)]
	fake.publishDeleteSchemaArgsForCall = append(fake.publishDeleteSchemaArgsForCall, struct {
		arg1 context.Context
		arg2 *protos.Schema
	}{arg1, arg2})
	stub := fake.PublishDeleteSchemaStub
	fakeReturns := fake.publishDeleteSchemaReturns
	fake.recordInvocation("PublishDeleteSchema", []interface{}{arg1, arg2})
	fake.publishDeleteSchemaMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) PublishDeleteSchemaCallCount() int {
	fake.publishDeleteSchemaMutex.RLock()
	defer fake.publishDeleteSchemaMutex.RUnlock()
	return len(fake.publishDeleteSchemaArgsForCall)
}

func (fake *FakeIEtcd) PublishDeleteSchemaCalls(stub func(context.Context, *protos.Schema) error) {
	fake.publishDeleteSchemaMutex.Lock()
	defer fake.publishDeleteSchemaMutex.Unlock()
	fake.PublishDeleteSchemaStub = stub
}

func (fake *FakeIEtcd) PublishDeleteSchemaArgsForCall(i int) (context.Context, *protos.Schema) {
	fake.publishDeleteSchemaMutex.RLock()
	defer fake.publishDeleteSchemaMutex.RUnlock()
	argsForCall := fake.publishDeleteSchemaArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIEtcd) PublishDeleteSchemaReturns(result1 error) {
	fake.publishDeleteSchemaMutex.Lock()
	defer fake.publishDeleteSchemaMutex.Unlock()
	fake.PublishDeleteSchemaStub = nil
	fake.publishDeleteSchemaReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishDeleteSchemaReturnsOnCall(i int, result1 error) {
	fake.publishDeleteSchemaMutex.Lock()
	defer fake.publishDeleteSchemaMutex.Unlock()
	fake.PublishDeleteSchemaStub = nil
	if fake.publishDeleteSchemaReturnsOnCall == nil {
		fake.publishDeleteSchemaReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.publishDeleteSchemaReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishDeleteService(arg1 context.Context, arg2 *protos.Service) error {
	fake.publishDeleteServiceMutex.Lock()
	ret, specificReturn := fake.publishDeleteServiceReturnsOnCall[len(fake.publishDeleteServiceArgsForCall)]
	fake.publishDeleteServiceArgsForCall = append(fake.publishDeleteServiceArgsForCall, struct {
		arg1 context.Context
		arg2 *protos.Service
	}{arg1, arg2})
	stub := fake.PublishDeleteServiceStub
	fakeReturns := fake.publishDeleteServiceReturns
	fake.recordInvocation("PublishDeleteService", []interface{}{arg1, arg2})
	fake.publishDeleteServiceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) PublishDeleteServiceCallCount() int {
	fake.publishDeleteServiceMutex.RLock()
	defer fake.publishDeleteServiceMutex.RUnlock()
	return len(fake.publishDeleteServiceArgsForCall)
}

func (fake *FakeIEtcd) PublishDeleteServiceCalls(stub func(context.Context, *protos.Service) error) {
	fake.publishDeleteServiceMutex.Lock()
	defer fake.publishDeleteServiceMutex.Unlock()
	fake.PublishDeleteServiceStub = stub
}

func (fake *FakeIEtcd) PublishDeleteServiceArgsForCall(i int) (context.Context, *protos.Service) {
	fake.publishDeleteServiceMutex.RLock()
	defer fake.publishDeleteServiceMutex.RUnlock()
	argsForCall := fake.publishDeleteServiceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIEtcd) PublishDeleteServiceReturns(result1 error) {
	fake.publishDeleteServiceMutex.Lock()
	defer fake.publishDeleteServiceMutex.Unlock()
	fake.PublishDeleteServiceStub = nil
	fake.publishDeleteServiceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishDeleteServiceReturnsOnCall(i int, result1 error) {
	fake.publishDeleteServiceMutex.Lock()
	defer fake.publishDeleteServiceMutex.Unlock()
	fake.PublishDeleteServiceStub = nil
	if fake.publishDeleteServiceReturnsOnCall == nil {
		fake.publishDeleteServiceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.publishDeleteServiceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishDeleteValidation(arg1 context.Context, arg2 *common.Validation) error {
	fake.publishDeleteValidationMutex.Lock()
	ret, specificReturn := fake.publishDeleteValidationReturnsOnCall[len(fake.publishDeleteValidationArgsForCall)]
	fake.publishDeleteValidationArgsForCall = append(fake.publishDeleteValidationArgsForCall, struct {
		arg1 context.Context
		arg2 *common.Validation
	}{arg1, arg2})
	stub := fake.PublishDeleteValidationStub
	fakeReturns := fake.publishDeleteValidationReturns
	fake.recordInvocation("PublishDeleteValidation", []interface{}{arg1, arg2})
	fake.publishDeleteValidationMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) PublishDeleteValidationCallCount() int {
	fake.publishDeleteValidationMutex.RLock()
	defer fake.publishDeleteValidationMutex.RUnlock()
	return len(fake.publishDeleteValidationArgsForCall)
}

func (fake *FakeIEtcd) PublishDeleteValidationCalls(stub func(context.Context, *common.Validation) error) {
	fake.publishDeleteValidationMutex.Lock()
	defer fake.publishDeleteValidationMutex.Unlock()
	fake.PublishDeleteValidationStub = stub
}

func (fake *FakeIEtcd) PublishDeleteValidationArgsForCall(i int) (context.Context, *common.Validation) {
	fake.publishDeleteValidationMutex.RLock()
	defer fake.publishDeleteValidationMutex.RUnlock()
	argsForCall := fake.publishDeleteValidationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIEtcd) PublishDeleteValidationReturns(result1 error) {
	fake.publishDeleteValidationMutex.Lock()
	defer fake.publishDeleteValidationMutex.Unlock()
	fake.PublishDeleteValidationStub = nil
	fake.publishDeleteValidationReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishDeleteValidationReturnsOnCall(i int, result1 error) {
	fake.publishDeleteValidationMutex.Lock()
	defer fake.publishDeleteValidationMutex.Unlock()
	fake.PublishDeleteValidationStub = nil
	if fake.publishDeleteValidationReturnsOnCall == nil {
		fake.publishDeleteValidationReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.publishDeleteValidationReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishResumeDynamic(arg1 context.Context, arg2 *opts.DynamicOptions) error {
	fake.publishResumeDynamicMutex.Lock()
	ret, specificReturn := fake.publishResumeDynamicReturnsOnCall[len(fake.publishResumeDynamicArgsForCall)]
	fake.publishResumeDynamicArgsForCall = append(fake.publishResumeDynamicArgsForCall, struct {
		arg1 context.Context
		arg2 *opts.DynamicOptions
	}{arg1, arg2})
	stub := fake.PublishResumeDynamicStub
	fakeReturns := fake.publishResumeDynamicReturns
	fake.recordInvocation("PublishResumeDynamic", []interface{}{arg1, arg2})
	fake.publishResumeDynamicMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) PublishResumeDynamicCallCount() int {
	fake.publishResumeDynamicMutex.RLock()
	defer fake.publishResumeDynamicMutex.RUnlock()
	return len(fake.publishResumeDynamicArgsForCall)
}

func (fake *FakeIEtcd) PublishResumeDynamicCalls(stub func(context.Context, *opts.DynamicOptions) error) {
	fake.publishResumeDynamicMutex.Lock()
	defer fake.publishResumeDynamicMutex.Unlock()
	fake.PublishResumeDynamicStub = stub
}

func (fake *FakeIEtcd) PublishResumeDynamicArgsForCall(i int) (context.Context, *opts.DynamicOptions) {
	fake.publishResumeDynamicMutex.RLock()
	defer fake.publishResumeDynamicMutex.RUnlock()
	argsForCall := fake.publishResumeDynamicArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIEtcd) PublishResumeDynamicReturns(result1 error) {
	fake.publishResumeDynamicMutex.Lock()
	defer fake.publishResumeDynamicMutex.Unlock()
	fake.PublishResumeDynamicStub = nil
	fake.publishResumeDynamicReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishResumeDynamicReturnsOnCall(i int, result1 error) {
	fake.publishResumeDynamicMutex.Lock()
	defer fake.publishResumeDynamicMutex.Unlock()
	fake.PublishResumeDynamicStub = nil
	if fake.publishResumeDynamicReturnsOnCall == nil {
		fake.publishResumeDynamicReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.publishResumeDynamicReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishResumeRelay(arg1 context.Context, arg2 *opts.RelayOptions) error {
	fake.publishResumeRelayMutex.Lock()
	ret, specificReturn := fake.publishResumeRelayReturnsOnCall[len(fake.publishResumeRelayArgsForCall)]
	fake.publishResumeRelayArgsForCall = append(fake.publishResumeRelayArgsForCall, struct {
		arg1 context.Context
		arg2 *opts.RelayOptions
	}{arg1, arg2})
	stub := fake.PublishResumeRelayStub
	fakeReturns := fake.publishResumeRelayReturns
	fake.recordInvocation("PublishResumeRelay", []interface{}{arg1, arg2})
	fake.publishResumeRelayMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) PublishResumeRelayCallCount() int {
	fake.publishResumeRelayMutex.RLock()
	defer fake.publishResumeRelayMutex.RUnlock()
	return len(fake.publishResumeRelayArgsForCall)
}

func (fake *FakeIEtcd) PublishResumeRelayCalls(stub func(context.Context, *opts.RelayOptions) error) {
	fake.publishResumeRelayMutex.Lock()
	defer fake.publishResumeRelayMutex.Unlock()
	fake.PublishResumeRelayStub = stub
}

func (fake *FakeIEtcd) PublishResumeRelayArgsForCall(i int) (context.Context, *opts.RelayOptions) {
	fake.publishResumeRelayMutex.RLock()
	defer fake.publishResumeRelayMutex.RUnlock()
	argsForCall := fake.publishResumeRelayArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIEtcd) PublishResumeRelayReturns(result1 error) {
	fake.publishResumeRelayMutex.Lock()
	defer fake.publishResumeRelayMutex.Unlock()
	fake.PublishResumeRelayStub = nil
	fake.publishResumeRelayReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishResumeRelayReturnsOnCall(i int, result1 error) {
	fake.publishResumeRelayMutex.Lock()
	defer fake.publishResumeRelayMutex.Unlock()
	fake.PublishResumeRelayStub = nil
	if fake.publishResumeRelayReturnsOnCall == nil {
		fake.publishResumeRelayReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.publishResumeRelayReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishStopDynamic(arg1 context.Context, arg2 *opts.DynamicOptions) error {
	fake.publishStopDynamicMutex.Lock()
	ret, specificReturn := fake.publishStopDynamicReturnsOnCall[len(fake.publishStopDynamicArgsForCall)]
	fake.publishStopDynamicArgsForCall = append(fake.publishStopDynamicArgsForCall, struct {
		arg1 context.Context
		arg2 *opts.DynamicOptions
	}{arg1, arg2})
	stub := fake.PublishStopDynamicStub
	fakeReturns := fake.publishStopDynamicReturns
	fake.recordInvocation("PublishStopDynamic", []interface{}{arg1, arg2})
	fake.publishStopDynamicMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) PublishStopDynamicCallCount() int {
	fake.publishStopDynamicMutex.RLock()
	defer fake.publishStopDynamicMutex.RUnlock()
	return len(fake.publishStopDynamicArgsForCall)
}

func (fake *FakeIEtcd) PublishStopDynamicCalls(stub func(context.Context, *opts.DynamicOptions) error) {
	fake.publishStopDynamicMutex.Lock()
	defer fake.publishStopDynamicMutex.Unlock()
	fake.PublishStopDynamicStub = stub
}

func (fake *FakeIEtcd) PublishStopDynamicArgsForCall(i int) (context.Context, *opts.DynamicOptions) {
	fake.publishStopDynamicMutex.RLock()
	defer fake.publishStopDynamicMutex.RUnlock()
	argsForCall := fake.publishStopDynamicArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIEtcd) PublishStopDynamicReturns(result1 error) {
	fake.publishStopDynamicMutex.Lock()
	defer fake.publishStopDynamicMutex.Unlock()
	fake.PublishStopDynamicStub = nil
	fake.publishStopDynamicReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishStopDynamicReturnsOnCall(i int, result1 error) {
	fake.publishStopDynamicMutex.Lock()
	defer fake.publishStopDynamicMutex.Unlock()
	fake.PublishStopDynamicStub = nil
	if fake.publishStopDynamicReturnsOnCall == nil {
		fake.publishStopDynamicReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.publishStopDynamicReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishStopRelay(arg1 context.Context, arg2 *opts.RelayOptions) error {
	fake.publishStopRelayMutex.Lock()
	ret, specificReturn := fake.publishStopRelayReturnsOnCall[len(fake.publishStopRelayArgsForCall)]
	fake.publishStopRelayArgsForCall = append(fake.publishStopRelayArgsForCall, struct {
		arg1 context.Context
		arg2 *opts.RelayOptions
	}{arg1, arg2})
	stub := fake.PublishStopRelayStub
	fakeReturns := fake.publishStopRelayReturns
	fake.recordInvocation("PublishStopRelay", []interface{}{arg1, arg2})
	fake.publishStopRelayMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) PublishStopRelayCallCount() int {
	fake.publishStopRelayMutex.RLock()
	defer fake.publishStopRelayMutex.RUnlock()
	return len(fake.publishStopRelayArgsForCall)
}

func (fake *FakeIEtcd) PublishStopRelayCalls(stub func(context.Context, *opts.RelayOptions) error) {
	fake.publishStopRelayMutex.Lock()
	defer fake.publishStopRelayMutex.Unlock()
	fake.PublishStopRelayStub = stub
}

func (fake *FakeIEtcd) PublishStopRelayArgsForCall(i int) (context.Context, *opts.RelayOptions) {
	fake.publishStopRelayMutex.RLock()
	defer fake.publishStopRelayMutex.RUnlock()
	argsForCall := fake.publishStopRelayArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIEtcd) PublishStopRelayReturns(result1 error) {
	fake.publishStopRelayMutex.Lock()
	defer fake.publishStopRelayMutex.Unlock()
	fake.PublishStopRelayStub = nil
	fake.publishStopRelayReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishStopRelayReturnsOnCall(i int, result1 error) {
	fake.publishStopRelayMutex.Lock()
	defer fake.publishStopRelayMutex.Unlock()
	fake.PublishStopRelayStub = nil
	if fake.publishStopRelayReturnsOnCall == nil {
		fake.publishStopRelayReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.publishStopRelayReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishUpdateComposite(arg1 context.Context, arg2 *opts.Composite) error {
	fake.publishUpdateCompositeMutex.Lock()
	ret, specificReturn := fake.publishUpdateCompositeReturnsOnCall[len(fake.publishUpdateCompositeArgsForCall)]
	fake.publishUpdateCompositeArgsForCall = append(fake.publishUpdateCompositeArgsForCall, struct {
		arg1 context.Context
		arg2 *opts.Composite
	}{arg1, arg2})
	stub := fake.PublishUpdateCompositeStub
	fakeReturns := fake.publishUpdateCompositeReturns
	fake.recordInvocation("PublishUpdateComposite", []interface{}{arg1, arg2})
	fake.publishUpdateCompositeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) PublishUpdateCompositeCallCount() int {
	fake.publishUpdateCompositeMutex.RLock()
	defer fake.publishUpdateCompositeMutex.RUnlock()
	return len(fake.publishUpdateCompositeArgsForCall)
}

func (fake *FakeIEtcd) PublishUpdateCompositeCalls(stub func(context.Context, *opts.Composite) error) {
	fake.publishUpdateCompositeMutex.Lock()
	defer fake.publishUpdateCompositeMutex.Unlock()
	fake.PublishUpdateCompositeStub = stub
}

func (fake *FakeIEtcd) PublishUpdateCompositeArgsForCall(i int) (context.Context, *opts.Composite) {
	fake.publishUpdateCompositeMutex.RLock()
	defer fake.publishUpdateCompositeMutex.RUnlock()
	argsForCall := fake.publishUpdateCompositeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIEtcd) PublishUpdateCompositeReturns(result1 error) {
	fake.publishUpdateCompositeMutex.Lock()
	defer fake.publishUpdateCompositeMutex.Unlock()
	fake.PublishUpdateCompositeStub = nil
	fake.publishUpdateCompositeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishUpdateCompositeReturnsOnCall(i int, result1 error) {
	fake.publishUpdateCompositeMutex.Lock()
	defer fake.publishUpdateCompositeMutex.Unlock()
	fake.PublishUpdateCompositeStub = nil
	if fake.publishUpdateCompositeReturnsOnCall == nil {
		fake.publishUpdateCompositeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.publishUpdateCompositeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishUpdateConnection(arg1 context.Context, arg2 *opts.ConnectionOptions) error {
	fake.publishUpdateConnectionMutex.Lock()
	ret, specificReturn := fake.publishUpdateConnectionReturnsOnCall[len(fake.publishUpdateConnectionArgsForCall)]
	fake.publishUpdateConnectionArgsForCall = append(fake.publishUpdateConnectionArgsForCall, struct {
		arg1 context.Context
		arg2 *opts.ConnectionOptions
	}{arg1, arg2})
	stub := fake.PublishUpdateConnectionStub
	fakeReturns := fake.publishUpdateConnectionReturns
	fake.recordInvocation("PublishUpdateConnection", []interface{}{arg1, arg2})
	fake.publishUpdateConnectionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) PublishUpdateConnectionCallCount() int {
	fake.publishUpdateConnectionMutex.RLock()
	defer fake.publishUpdateConnectionMutex.RUnlock()
	return len(fake.publishUpdateConnectionArgsForCall)
}

func (fake *FakeIEtcd) PublishUpdateConnectionCalls(stub func(context.Context, *opts.ConnectionOptions) error) {
	fake.publishUpdateConnectionMutex.Lock()
	defer fake.publishUpdateConnectionMutex.Unlock()
	fake.PublishUpdateConnectionStub = stub
}

func (fake *FakeIEtcd) PublishUpdateConnectionArgsForCall(i int) (context.Context, *opts.ConnectionOptions) {
	fake.publishUpdateConnectionMutex.RLock()
	defer fake.publishUpdateConnectionMutex.RUnlock()
	argsForCall := fake.publishUpdateConnectionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIEtcd) PublishUpdateConnectionReturns(result1 error) {
	fake.publishUpdateConnectionMutex.Lock()
	defer fake.publishUpdateConnectionMutex.Unlock()
	fake.PublishUpdateConnectionStub = nil
	fake.publishUpdateConnectionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishUpdateConnectionReturnsOnCall(i int, result1 error) {
	fake.publishUpdateConnectionMutex.Lock()
	defer fake.publishUpdateConnectionMutex.Unlock()
	fake.PublishUpdateConnectionStub = nil
	if fake.publishUpdateConnectionReturnsOnCall == nil {
		fake.publishUpdateConnectionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.publishUpdateConnectionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishUpdateDynamic(arg1 context.Context, arg2 *opts.DynamicOptions) error {
	fake.publishUpdateDynamicMutex.Lock()
	ret, specificReturn := fake.publishUpdateDynamicReturnsOnCall[len(fake.publishUpdateDynamicArgsForCall)]
	fake.publishUpdateDynamicArgsForCall = append(fake.publishUpdateDynamicArgsForCall, struct {
		arg1 context.Context
		arg2 *opts.DynamicOptions
	}{arg1, arg2})
	stub := fake.PublishUpdateDynamicStub
	fakeReturns := fake.publishUpdateDynamicReturns
	fake.recordInvocation("PublishUpdateDynamic", []interface{}{arg1, arg2})
	fake.publishUpdateDynamicMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) PublishUpdateDynamicCallCount() int {
	fake.publishUpdateDynamicMutex.RLock()
	defer fake.publishUpdateDynamicMutex.RUnlock()
	return len(fake.publishUpdateDynamicArgsForCall)
}

func (fake *FakeIEtcd) PublishUpdateDynamicCalls(stub func(context.Context, *opts.DynamicOptions) error) {
	fake.publishUpdateDynamicMutex.Lock()
	defer fake.publishUpdateDynamicMutex.Unlock()
	fake.PublishUpdateDynamicStub = stub
}

func (fake *FakeIEtcd) PublishUpdateDynamicArgsForCall(i int) (context.Context, *opts.DynamicOptions) {
	fake.publishUpdateDynamicMutex.RLock()
	defer fake.publishUpdateDynamicMutex.RUnlock()
	argsForCall := fake.publishUpdateDynamicArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIEtcd) PublishUpdateDynamicReturns(result1 error) {
	fake.publishUpdateDynamicMutex.Lock()
	defer fake.publishUpdateDynamicMutex.Unlock()
	fake.PublishUpdateDynamicStub = nil
	fake.publishUpdateDynamicReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishUpdateDynamicReturnsOnCall(i int, result1 error) {
	fake.publishUpdateDynamicMutex.Lock()
	defer fake.publishUpdateDynamicMutex.Unlock()
	fake.PublishUpdateDynamicStub = nil
	if fake.publishUpdateDynamicReturnsOnCall == nil {
		fake.publishUpdateDynamicReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.publishUpdateDynamicReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishUpdateRelay(arg1 context.Context, arg2 *opts.RelayOptions) error {
	fake.publishUpdateRelayMutex.Lock()
	ret, specificReturn := fake.publishUpdateRelayReturnsOnCall[len(fake.publishUpdateRelayArgsForCall)]
	fake.publishUpdateRelayArgsForCall = append(fake.publishUpdateRelayArgsForCall, struct {
		arg1 context.Context
		arg2 *opts.RelayOptions
	}{arg1, arg2})
	stub := fake.PublishUpdateRelayStub
	fakeReturns := fake.publishUpdateRelayReturns
	fake.recordInvocation("PublishUpdateRelay", []interface{}{arg1, arg2})
	fake.publishUpdateRelayMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) PublishUpdateRelayCallCount() int {
	fake.publishUpdateRelayMutex.RLock()
	defer fake.publishUpdateRelayMutex.RUnlock()
	return len(fake.publishUpdateRelayArgsForCall)
}

func (fake *FakeIEtcd) PublishUpdateRelayCalls(stub func(context.Context, *opts.RelayOptions) error) {
	fake.publishUpdateRelayMutex.Lock()
	defer fake.publishUpdateRelayMutex.Unlock()
	fake.PublishUpdateRelayStub = stub
}

func (fake *FakeIEtcd) PublishUpdateRelayArgsForCall(i int) (context.Context, *opts.RelayOptions) {
	fake.publishUpdateRelayMutex.RLock()
	defer fake.publishUpdateRelayMutex.RUnlock()
	argsForCall := fake.publishUpdateRelayArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIEtcd) PublishUpdateRelayReturns(result1 error) {
	fake.publishUpdateRelayMutex.Lock()
	defer fake.publishUpdateRelayMutex.Unlock()
	fake.PublishUpdateRelayStub = nil
	fake.publishUpdateRelayReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishUpdateRelayReturnsOnCall(i int, result1 error) {
	fake.publishUpdateRelayMutex.Lock()
	defer fake.publishUpdateRelayMutex.Unlock()
	fake.PublishUpdateRelayStub = nil
	if fake.publishUpdateRelayReturnsOnCall == nil {
		fake.publishUpdateRelayReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.publishUpdateRelayReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishUpdateSchema(arg1 context.Context, arg2 *protos.Schema) error {
	fake.publishUpdateSchemaMutex.Lock()
	ret, specificReturn := fake.publishUpdateSchemaReturnsOnCall[len(fake.publishUpdateSchemaArgsForCall)]
	fake.publishUpdateSchemaArgsForCall = append(fake.publishUpdateSchemaArgsForCall, struct {
		arg1 context.Context
		arg2 *protos.Schema
	}{arg1, arg2})
	stub := fake.PublishUpdateSchemaStub
	fakeReturns := fake.publishUpdateSchemaReturns
	fake.recordInvocation("PublishUpdateSchema", []interface{}{arg1, arg2})
	fake.publishUpdateSchemaMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) PublishUpdateSchemaCallCount() int {
	fake.publishUpdateSchemaMutex.RLock()
	defer fake.publishUpdateSchemaMutex.RUnlock()
	return len(fake.publishUpdateSchemaArgsForCall)
}

func (fake *FakeIEtcd) PublishUpdateSchemaCalls(stub func(context.Context, *protos.Schema) error) {
	fake.publishUpdateSchemaMutex.Lock()
	defer fake.publishUpdateSchemaMutex.Unlock()
	fake.PublishUpdateSchemaStub = stub
}

func (fake *FakeIEtcd) PublishUpdateSchemaArgsForCall(i int) (context.Context, *protos.Schema) {
	fake.publishUpdateSchemaMutex.RLock()
	defer fake.publishUpdateSchemaMutex.RUnlock()
	argsForCall := fake.publishUpdateSchemaArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIEtcd) PublishUpdateSchemaReturns(result1 error) {
	fake.publishUpdateSchemaMutex.Lock()
	defer fake.publishUpdateSchemaMutex.Unlock()
	fake.PublishUpdateSchemaStub = nil
	fake.publishUpdateSchemaReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishUpdateSchemaReturnsOnCall(i int, result1 error) {
	fake.publishUpdateSchemaMutex.Lock()
	defer fake.publishUpdateSchemaMutex.Unlock()
	fake.PublishUpdateSchemaStub = nil
	if fake.publishUpdateSchemaReturnsOnCall == nil {
		fake.publishUpdateSchemaReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.publishUpdateSchemaReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishUpdateService(arg1 context.Context, arg2 *protos.Service) error {
	fake.publishUpdateServiceMutex.Lock()
	ret, specificReturn := fake.publishUpdateServiceReturnsOnCall[len(fake.publishUpdateServiceArgsForCall)]
	fake.publishUpdateServiceArgsForCall = append(fake.publishUpdateServiceArgsForCall, struct {
		arg1 context.Context
		arg2 *protos.Service
	}{arg1, arg2})
	stub := fake.PublishUpdateServiceStub
	fakeReturns := fake.publishUpdateServiceReturns
	fake.recordInvocation("PublishUpdateService", []interface{}{arg1, arg2})
	fake.publishUpdateServiceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) PublishUpdateServiceCallCount() int {
	fake.publishUpdateServiceMutex.RLock()
	defer fake.publishUpdateServiceMutex.RUnlock()
	return len(fake.publishUpdateServiceArgsForCall)
}

func (fake *FakeIEtcd) PublishUpdateServiceCalls(stub func(context.Context, *protos.Service) error) {
	fake.publishUpdateServiceMutex.Lock()
	defer fake.publishUpdateServiceMutex.Unlock()
	fake.PublishUpdateServiceStub = stub
}

func (fake *FakeIEtcd) PublishUpdateServiceArgsForCall(i int) (context.Context, *protos.Service) {
	fake.publishUpdateServiceMutex.RLock()
	defer fake.publishUpdateServiceMutex.RUnlock()
	argsForCall := fake.publishUpdateServiceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIEtcd) PublishUpdateServiceReturns(result1 error) {
	fake.publishUpdateServiceMutex.Lock()
	defer fake.publishUpdateServiceMutex.Unlock()
	fake.PublishUpdateServiceStub = nil
	fake.publishUpdateServiceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishUpdateServiceReturnsOnCall(i int, result1 error) {
	fake.publishUpdateServiceMutex.Lock()
	defer fake.publishUpdateServiceMutex.Unlock()
	fake.PublishUpdateServiceStub = nil
	if fake.publishUpdateServiceReturnsOnCall == nil {
		fake.publishUpdateServiceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.publishUpdateServiceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishUpdateValidation(arg1 context.Context, arg2 *common.Validation) error {
	fake.publishUpdateValidationMutex.Lock()
	ret, specificReturn := fake.publishUpdateValidationReturnsOnCall[len(fake.publishUpdateValidationArgsForCall)]
	fake.publishUpdateValidationArgsForCall = append(fake.publishUpdateValidationArgsForCall, struct {
		arg1 context.Context
		arg2 *common.Validation
	}{arg1, arg2})
	stub := fake.PublishUpdateValidationStub
	fakeReturns := fake.publishUpdateValidationReturns
	fake.recordInvocation("PublishUpdateValidation", []interface{}{arg1, arg2})
	fake.publishUpdateValidationMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) PublishUpdateValidationCallCount() int {
	fake.publishUpdateValidationMutex.RLock()
	defer fake.publishUpdateValidationMutex.RUnlock()
	return len(fake.publishUpdateValidationArgsForCall)
}

func (fake *FakeIEtcd) PublishUpdateValidationCalls(stub func(context.Context, *common.Validation) error) {
	fake.publishUpdateValidationMutex.Lock()
	defer fake.publishUpdateValidationMutex.Unlock()
	fake.PublishUpdateValidationStub = stub
}

func (fake *FakeIEtcd) PublishUpdateValidationArgsForCall(i int) (context.Context, *common.Validation) {
	fake.publishUpdateValidationMutex.RLock()
	defer fake.publishUpdateValidationMutex.RUnlock()
	argsForCall := fake.publishUpdateValidationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIEtcd) PublishUpdateValidationReturns(result1 error) {
	fake.publishUpdateValidationMutex.Lock()
	defer fake.publishUpdateValidationMutex.Unlock()
	fake.PublishUpdateValidationStub = nil
	fake.publishUpdateValidationReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishUpdateValidationReturnsOnCall(i int, result1 error) {
	fake.publishUpdateValidationMutex.Lock()
	defer fake.publishUpdateValidationMutex.Unlock()
	fake.PublishUpdateValidationStub = nil
	if fake.publishUpdateValidationReturnsOnCall == nil {
		fake.publishUpdateValidationReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.publishUpdateValidationReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) Put(arg1 context.Context, arg2 string, arg3 string, arg4 ...clientv3.OpOption) (*clientv3.PutResponse, error) {
	fake.putMutex.Lock()
	ret, specificReturn := fake.putReturnsOnCall[len(fake.putArgsForCall)]
	fake.putArgsForCall = append(fake.putArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 []clientv3.OpOption
	}{arg1, arg2, arg3, arg4})
	stub := fake.PutStub
	fakeReturns := fake.putReturns
	fake.recordInvocation("Put", []interface{}{arg1, arg2, arg3, arg4})
	fake.putMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIEtcd) PutCallCount() int {
	fake.putMutex.RLock()
	defer fake.putMutex.RUnlock()
	return len(fake.putArgsForCall)
}

func (fake *FakeIEtcd) PutCalls(stub func(context.Context, string, string, ...clientv3.OpOption) (*clientv3.PutResponse, error)) {
	fake.putMutex.Lock()
	defer fake.putMutex.Unlock()
	fake.PutStub = stub
}

func (fake *FakeIEtcd) PutArgsForCall(i int) (context.Context, string, string, []clientv3.OpOption) {
	fake.putMutex.RLock()
	defer fake.putMutex.RUnlock()
	argsForCall := fake.putArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeIEtcd) PutReturns(result1 *clientv3.PutResponse, result2 error) {
	fake.putMutex.Lock()
	defer fake.putMutex.Unlock()
	fake.PutStub = nil
	fake.putReturns = struct {
		result1 *clientv3.PutResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeIEtcd) PutReturnsOnCall(i int, result1 *clientv3.PutResponse, result2 error) {
	fake.putMutex.Lock()
	defer fake.putMutex.Unlock()
	fake.PutStub = nil
	if fake.putReturnsOnCall == nil {
		fake.putReturnsOnCall = make(map[int]struct {
			result1 *clientv3.PutResponse
			result2 error
		})
	}
	fake.putReturnsOnCall[i] = struct {
		result1 *clientv3.PutResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeIEtcd) PutWithTTL(arg1 context.Context, arg2 string, arg3 string, arg4 time.Duration) (*clientv3.PutResponse, error) {
	fake.putWithTTLMutex.Lock()
	ret, specificReturn := fake.putWithTTLReturnsOnCall[len(fake.putWithTTLArgsForCall)]
	fake.putWithTTLArgsForCall = append(fake.putWithTTLArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 time.Duration
	}{arg1, arg2, arg3, arg4})
	stub := fake.PutWithTTLStub
	fakeReturns := fake.putWithTTLReturns
	fake.recordInvocation("PutWithTTL", []interface{}{arg1, arg2, arg3, arg4})
	fake.putWithTTLMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIEtcd) PutWithTTLCallCount() int {
	fake.putWithTTLMutex.RLock()
	defer fake.putWithTTLMutex.RUnlock()
	return len(fake.putWithTTLArgsForCall)
}

func (fake *FakeIEtcd) PutWithTTLCalls(stub func(context.Context, string, string, time.Duration) (*clientv3.PutResponse, error)) {
	fake.putWithTTLMutex.Lock()
	defer fake.putWithTTLMutex.Unlock()
	fake.PutWithTTLStub = stub
}

func (fake *FakeIEtcd) PutWithTTLArgsForCall(i int) (context.Context, string, string, time.Duration) {
	fake.putWithTTLMutex.RLock()
	defer fake.putWithTTLMutex.RUnlock()
	argsForCall := fake.putWithTTLArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeIEtcd) PutWithTTLReturns(result1 *clientv3.PutResponse, result2 error) {
	fake.putWithTTLMutex.Lock()
	defer fake.putWithTTLMutex.Unlock()
	fake.PutWithTTLStub = nil
	fake.putWithTTLReturns = struct {
		result1 *clientv3.PutResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeIEtcd) PutWithTTLReturnsOnCall(i int, result1 *clientv3.PutResponse, result2 error) {
	fake.putWithTTLMutex.Lock()
	defer fake.putWithTTLMutex.Unlock()
	fake.PutWithTTLStub = nil
	if fake.putWithTTLReturnsOnCall == nil {
		fake.putWithTTLReturnsOnCall = make(map[int]struct {
			result1 *clientv3.PutResponse
			result2 error
		})
	}
	fake.putWithTTLReturnsOnCall[i] = struct {
		result1 *clientv3.PutResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeIEtcd) SaveConfig(arg1 context.Context, arg2 *config.Config) error {
	fake.saveConfigMutex.Lock()
	ret, specificReturn := fake.saveConfigReturnsOnCall[len(fake.saveConfigArgsForCall)]
	fake.saveConfigArgsForCall = append(fake.saveConfigArgsForCall, struct {
		arg1 context.Context
		arg2 *config.Config
	}{arg1, arg2})
	stub := fake.SaveConfigStub
	fakeReturns := fake.saveConfigReturns
	fake.recordInvocation("SaveConfig", []interface{}{arg1, arg2})
	fake.saveConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) SaveConfigCallCount() int {
	fake.saveConfigMutex.RLock()
	defer fake.saveConfigMutex.RUnlock()
	return len(fake.saveConfigArgsForCall)
}

func (fake *FakeIEtcd) SaveConfigCalls(stub func(context.Context, *config.Config) error) {
	fake.saveConfigMutex.Lock()
	defer fake.saveConfigMutex.Unlock()
	fake.SaveConfigStub = stub
}

func (fake *FakeIEtcd) SaveConfigArgsForCall(i int) (context.Context, *config.Config) {
	fake.saveConfigMutex.RLock()
	defer fake.saveConfigMutex.RUnlock()
	argsForCall := fake.saveConfigArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIEtcd) SaveConfigReturns(result1 error) {
	fake.saveConfigMutex.Lock()
	defer fake.saveConfigMutex.Unlock()
	fake.SaveConfigStub = nil
	fake.saveConfigReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) SaveConfigReturnsOnCall(i int, result1 error) {
	fake.saveConfigMutex.Lock()
	defer fake.saveConfigMutex.Unlock()
	fake.SaveConfigStub = nil
	if fake.saveConfigReturnsOnCall == nil {
		fake.saveConfigReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveConfigReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) Shutdown(arg1 bool) error {
	fake.shutdownMutex.Lock()
	ret, specificReturn := fake.shutdownReturnsOnCall[len(fake.shutdownArgsForCall)]
	fake.shutdownArgsForCall = append(fake.shutdownArgsForCall, struct {
		arg1 bool
	}{arg1})
	stub := fake.ShutdownStub
	fakeReturns := fake.shutdownReturns
	fake.recordInvocation("Shutdown", []interface{}{arg1})
	fake.shutdownMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) ShutdownCallCount() int {
	fake.shutdownMutex.RLock()
	defer fake.shutdownMutex.RUnlock()
	return len(fake.shutdownArgsForCall)
}

func (fake *FakeIEtcd) ShutdownCalls(stub func(bool) error) {
	fake.shutdownMutex.Lock()
	defer fake.shutdownMutex.Unlock()
	fake.ShutdownStub = stub
}

func (fake *FakeIEtcd) ShutdownArgsForCall(i int) bool {
	fake.shutdownMutex.RLock()
	defer fake.shutdownMutex.RUnlock()
	argsForCall := fake.shutdownArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIEtcd) ShutdownReturns(result1 error) {
	fake.shutdownMutex.Lock()
	defer fake.shutdownMutex.Unlock()
	fake.ShutdownStub = nil
	fake.shutdownReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) ShutdownReturnsOnCall(i int, result1 error) {
	fake.shutdownMutex.Lock()
	defer fake.shutdownMutex.Unlock()
	fake.ShutdownStub = nil
	if fake.shutdownReturnsOnCall == nil {
		fake.shutdownReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.shutdownReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) Start(arg1 context.Context) error {
	fake.startMutex.Lock()
	ret, specificReturn := fake.startReturnsOnCall[len(fake.startArgsForCall)]
	fake.startArgsForCall = append(fake.startArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.StartStub
	fakeReturns := fake.startReturns
	fake.recordInvocation("Start", []interface{}{arg1})
	fake.startMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) StartCallCount() int {
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	return len(fake.startArgsForCall)
}

func (fake *FakeIEtcd) StartCalls(stub func(context.Context) error) {
	fake.startMutex.Lock()
	defer fake.startMutex.Unlock()
	fake.StartStub = stub
}

func (fake *FakeIEtcd) StartArgsForCall(i int) context.Context {
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	argsForCall := fake.startArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIEtcd) StartReturns(result1 error) {
	fake.startMutex.Lock()
	defer fake.startMutex.Unlock()
	fake.StartStub = nil
	fake.startReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) StartReturnsOnCall(i int, result1 error) {
	fake.startMutex.Lock()
	defer fake.startMutex.Unlock()
	fake.StartStub = nil
	if fake.startReturnsOnCall == nil {
		fake.startReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.startReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.broadcastMutex.RLock()
	defer fake.broadcastMutex.RUnlock()
	fake.clientMutex.RLock()
	defer fake.clientMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.directMutex.RLock()
	defer fake.directMutex.RUnlock()
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	fake.grantLeaseMutex.RLock()
	defer fake.grantLeaseMutex.RUnlock()
	fake.publishConfigUpdateMutex.RLock()
	defer fake.publishConfigUpdateMutex.RUnlock()
	fake.publishCreateCompositeMutex.RLock()
	defer fake.publishCreateCompositeMutex.RUnlock()
	fake.publishCreateConnectionMutex.RLock()
	defer fake.publishCreateConnectionMutex.RUnlock()
	fake.publishCreateDynamicMutex.RLock()
	defer fake.publishCreateDynamicMutex.RUnlock()
	fake.publishCreateReadMutex.RLock()
	defer fake.publishCreateReadMutex.RUnlock()
	fake.publishCreateRelayMutex.RLock()
	defer fake.publishCreateRelayMutex.RUnlock()
	fake.publishCreateSchemaMutex.RLock()
	defer fake.publishCreateSchemaMutex.RUnlock()
	fake.publishCreateServiceMutex.RLock()
	defer fake.publishCreateServiceMutex.RUnlock()
	fake.publishCreateValidationMutex.RLock()
	defer fake.publishCreateValidationMutex.RUnlock()
	fake.publishDeleteCompositeMutex.RLock()
	defer fake.publishDeleteCompositeMutex.RUnlock()
	fake.publishDeleteConnectionMutex.RLock()
	defer fake.publishDeleteConnectionMutex.RUnlock()
	fake.publishDeleteDynamicMutex.RLock()
	defer fake.publishDeleteDynamicMutex.RUnlock()
	fake.publishDeleteReadMutex.RLock()
	defer fake.publishDeleteReadMutex.RUnlock()
	fake.publishDeleteRelayMutex.RLock()
	defer fake.publishDeleteRelayMutex.RUnlock()
	fake.publishDeleteSchemaMutex.RLock()
	defer fake.publishDeleteSchemaMutex.RUnlock()
	fake.publishDeleteServiceMutex.RLock()
	defer fake.publishDeleteServiceMutex.RUnlock()
	fake.publishDeleteValidationMutex.RLock()
	defer fake.publishDeleteValidationMutex.RUnlock()
	fake.publishResumeDynamicMutex.RLock()
	defer fake.publishResumeDynamicMutex.RUnlock()
	fake.publishResumeRelayMutex.RLock()
	defer fake.publishResumeRelayMutex.RUnlock()
	fake.publishStopDynamicMutex.RLock()
	defer fake.publishStopDynamicMutex.RUnlock()
	fake.publishStopRelayMutex.RLock()
	defer fake.publishStopRelayMutex.RUnlock()
	fake.publishUpdateCompositeMutex.RLock()
	defer fake.publishUpdateCompositeMutex.RUnlock()
	fake.publishUpdateConnectionMutex.RLock()
	defer fake.publishUpdateConnectionMutex.RUnlock()
	fake.publishUpdateDynamicMutex.RLock()
	defer fake.publishUpdateDynamicMutex.RUnlock()
	fake.publishUpdateRelayMutex.RLock()
	defer fake.publishUpdateRelayMutex.RUnlock()
	fake.publishUpdateSchemaMutex.RLock()
	defer fake.publishUpdateSchemaMutex.RUnlock()
	fake.publishUpdateServiceMutex.RLock()
	defer fake.publishUpdateServiceMutex.RUnlock()
	fake.publishUpdateValidationMutex.RLock()
	defer fake.publishUpdateValidationMutex.RUnlock()
	fake.putMutex.RLock()
	defer fake.putMutex.RUnlock()
	fake.putWithTTLMutex.RLock()
	defer fake.putWithTTLMutex.RUnlock()
	fake.saveConfigMutex.RLock()
	defer fake.saveConfigMutex.RUnlock()
	fake.shutdownMutex.RLock()
	defer fake.shutdownMutex.RUnlock()
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeIEtcd) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ etcd.IEtcd = new(FakeIEtcd)

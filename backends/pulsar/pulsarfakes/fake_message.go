// Code generated by counterfeiter. DO NOT EDIT.
package pulsarfakes

import (
	"sync"
	"time"

	"github.com/apache/pulsar-client-go/pulsar"
)

type FakeMessage struct {
	BrokerPublishTimeStub        func() *time.Time
	brokerPublishTimeMutex       sync.RWMutex
	brokerPublishTimeArgsForCall []struct {
	}
	brokerPublishTimeReturns struct {
		result1 *time.Time
	}
	brokerPublishTimeReturnsOnCall map[int]struct {
		result1 *time.Time
	}
	EventTimeStub        func() time.Time
	eventTimeMutex       sync.RWMutex
	eventTimeArgsForCall []struct {
	}
	eventTimeReturns struct {
		result1 time.Time
	}
	eventTimeReturnsOnCall map[int]struct {
		result1 time.Time
	}
	GetEncryptionContextStub        func() *pulsar.EncryptionContext
	getEncryptionContextMutex       sync.RWMutex
	getEncryptionContextArgsForCall []struct {
	}
	getEncryptionContextReturns struct {
		result1 *pulsar.EncryptionContext
	}
	getEncryptionContextReturnsOnCall map[int]struct {
		result1 *pulsar.EncryptionContext
	}
	GetReplicatedFromStub        func() string
	getReplicatedFromMutex       sync.RWMutex
	getReplicatedFromArgsForCall []struct {
	}
	getReplicatedFromReturns struct {
		result1 string
	}
	getReplicatedFromReturnsOnCall map[int]struct {
		result1 string
	}
	GetSchemaValueStub        func(interface{}) error
	getSchemaValueMutex       sync.RWMutex
	getSchemaValueArgsForCall []struct {
		arg1 interface{}
	}
	getSchemaValueReturns struct {
		result1 error
	}
	getSchemaValueReturnsOnCall map[int]struct {
		result1 error
	}
	IDStub        func() pulsar.MessageID
	iDMutex       sync.RWMutex
	iDArgsForCall []struct {
	}
	iDReturns struct {
		result1 pulsar.MessageID
	}
	iDReturnsOnCall map[int]struct {
		result1 pulsar.MessageID
	}
	IndexStub        func() *uint64
	indexMutex       sync.RWMutex
	indexArgsForCall []struct {
	}
	indexReturns struct {
		result1 *uint64
	}
	indexReturnsOnCall map[int]struct {
		result1 *uint64
	}
	IsReplicatedStub        func() bool
	isReplicatedMutex       sync.RWMutex
	isReplicatedArgsForCall []struct {
	}
	isReplicatedReturns struct {
		result1 bool
	}
	isReplicatedReturnsOnCall map[int]struct {
		result1 bool
	}
	KeyStub        func() string
	keyMutex       sync.RWMutex
	keyArgsForCall []struct {
	}
	keyReturns struct {
		result1 string
	}
	keyReturnsOnCall map[int]struct {
		result1 string
	}
	OrderingKeyStub        func() string
	orderingKeyMutex       sync.RWMutex
	orderingKeyArgsForCall []struct {
	}
	orderingKeyReturns struct {
		result1 string
	}
	orderingKeyReturnsOnCall map[int]struct {
		result1 string
	}
	PayloadStub        func() []byte
	payloadMutex       sync.RWMutex
	payloadArgsForCall []struct {
	}
	payloadReturns struct {
		result1 []byte
	}
	payloadReturnsOnCall map[int]struct {
		result1 []byte
	}
	ProducerNameStub        func() string
	producerNameMutex       sync.RWMutex
	producerNameArgsForCall []struct {
	}
	producerNameReturns struct {
		result1 string
	}
	producerNameReturnsOnCall map[int]struct {
		result1 string
	}
	PropertiesStub        func() map[string]string
	propertiesMutex       sync.RWMutex
	propertiesArgsForCall []struct {
	}
	propertiesReturns struct {
		result1 map[string]string
	}
	propertiesReturnsOnCall map[int]struct {
		result1 map[string]string
	}
	PublishTimeStub        func() time.Time
	publishTimeMutex       sync.RWMutex
	publishTimeArgsForCall []struct {
	}
	publishTimeReturns struct {
		result1 time.Time
	}
	publishTimeReturnsOnCall map[int]struct {
		result1 time.Time
	}
	RedeliveryCountStub        func() uint32
	redeliveryCountMutex       sync.RWMutex
	redeliveryCountArgsForCall []struct {
	}
	redeliveryCountReturns struct {
		result1 uint32
	}
	redeliveryCountReturnsOnCall map[int]struct {
		result1 uint32
	}
	SchemaVersionStub        func() []byte
	schemaVersionMutex       sync.RWMutex
	schemaVersionArgsForCall []struct {
	}
	schemaVersionReturns struct {
		result1 []byte
	}
	schemaVersionReturnsOnCall map[int]struct {
		result1 []byte
	}
	TopicStub        func() string
	topicMutex       sync.RWMutex
	topicArgsForCall []struct {
	}
	topicReturns struct {
		result1 string
	}
	topicReturnsOnCall map[int]struct {
		result1 string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeMessage) BrokerPublishTime() *time.Time {
	fake.brokerPublishTimeMutex.Lock()
	ret, specificReturn := fake.brokerPublishTimeReturnsOnCall[len(fake.brokerPublishTimeArgsForCall)]
	fake.brokerPublishTimeArgsForCall = append(fake.brokerPublishTimeArgsForCall, struct {
	}{})
	stub := fake.BrokerPublishTimeStub
	fakeReturns := fake.brokerPublishTimeReturns
	fake.recordInvocation("BrokerPublishTime", []interface{}{})
	fake.brokerPublishTimeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMessage) BrokerPublishTimeCallCount() int {
	fake.brokerPublishTimeMutex.RLock()
	defer fake.brokerPublishTimeMutex.RUnlock()
	return len(fake.brokerPublishTimeArgsForCall)
}

func (fake *FakeMessage) BrokerPublishTimeCalls(stub func() *time.Time) {
	fake.brokerPublishTimeMutex.Lock()
	defer fake.brokerPublishTimeMutex.Unlock()
	fake.BrokerPublishTimeStub = stub
}

func (fake *FakeMessage) BrokerPublishTimeReturns(result1 *time.Time) {
	fake.brokerPublishTimeMutex.Lock()
	defer fake.brokerPublishTimeMutex.Unlock()
	fake.BrokerPublishTimeStub = nil
	fake.brokerPublishTimeReturns = struct {
		result1 *time.Time
	}{result1}
}

func (fake *FakeMessage) BrokerPublishTimeReturnsOnCall(i int, result1 *time.Time) {
	fake.brokerPublishTimeMutex.Lock()
	defer fake.brokerPublishTimeMutex.Unlock()
	fake.BrokerPublishTimeStub = nil
	if fake.brokerPublishTimeReturnsOnCall == nil {
		fake.brokerPublishTimeReturnsOnCall = make(map[int]struct {
			result1 *time.Time
		})
	}
	fake.brokerPublishTimeReturnsOnCall[i] = struct {
		result1 *time.Time
	}{result1}
}

func (fake *FakeMessage) EventTime() time.Time {
	fake.eventTimeMutex.Lock()
	ret, specificReturn := fake.eventTimeReturnsOnCall[len(fake.eventTimeArgsForCall)]
	fake.eventTimeArgsForCall = append(fake.eventTimeArgsForCall, struct {
	}{})
	stub := fake.EventTimeStub
	fakeReturns := fake.eventTimeReturns
	fake.recordInvocation("EventTime", []interface{}{})
	fake.eventTimeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMessage) EventTimeCallCount() int {
	fake.eventTimeMutex.RLock()
	defer fake.eventTimeMutex.RUnlock()
	return len(fake.eventTimeArgsForCall)
}

func (fake *FakeMessage) EventTimeCalls(stub func() time.Time) {
	fake.eventTimeMutex.Lock()
	defer fake.eventTimeMutex.Unlock()
	fake.EventTimeStub = stub
}

func (fake *FakeMessage) EventTimeReturns(result1 time.Time) {
	fake.eventTimeMutex.Lock()
	defer fake.eventTimeMutex.Unlock()
	fake.EventTimeStub = nil
	fake.eventTimeReturns = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeMessage) EventTimeReturnsOnCall(i int, result1 time.Time) {
	fake.eventTimeMutex.Lock()
	defer fake.eventTimeMutex.Unlock()
	fake.EventTimeStub = nil
	if fake.eventTimeReturnsOnCall == nil {
		fake.eventTimeReturnsOnCall = make(map[int]struct {
			result1 time.Time
		})
	}
	fake.eventTimeReturnsOnCall[i] = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeMessage) GetEncryptionContext() *pulsar.EncryptionContext {
	fake.getEncryptionContextMutex.Lock()
	ret, specificReturn := fake.getEncryptionContextReturnsOnCall[len(fake.getEncryptionContextArgsForCall)]
	fake.getEncryptionContextArgsForCall = append(fake.getEncryptionContextArgsForCall, struct {
	}{})
	stub := fake.GetEncryptionContextStub
	fakeReturns := fake.getEncryptionContextReturns
	fake.recordInvocation("GetEncryptionContext", []interface{}{})
	fake.getEncryptionContextMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMessage) GetEncryptionContextCallCount() int {
	fake.getEncryptionContextMutex.RLock()
	defer fake.getEncryptionContextMutex.RUnlock()
	return len(fake.getEncryptionContextArgsForCall)
}

func (fake *FakeMessage) GetEncryptionContextCalls(stub func() *pulsar.EncryptionContext) {
	fake.getEncryptionContextMutex.Lock()
	defer fake.getEncryptionContextMutex.Unlock()
	fake.GetEncryptionContextStub = stub
}

func (fake *FakeMessage) GetEncryptionContextReturns(result1 *pulsar.EncryptionContext) {
	fake.getEncryptionContextMutex.Lock()
	defer fake.getEncryptionContextMutex.Unlock()
	fake.GetEncryptionContextStub = nil
	fake.getEncryptionContextReturns = struct {
		result1 *pulsar.EncryptionContext
	}{result1}
}

func (fake *FakeMessage) GetEncryptionContextReturnsOnCall(i int, result1 *pulsar.EncryptionContext) {
	fake.getEncryptionContextMutex.Lock()
	defer fake.getEncryptionContextMutex.Unlock()
	fake.GetEncryptionContextStub = nil
	if fake.getEncryptionContextReturnsOnCall == nil {
		fake.getEncryptionContextReturnsOnCall = make(map[int]struct {
			result1 *pulsar.EncryptionContext
		})
	}
	fake.getEncryptionContextReturnsOnCall[i] = struct {
		result1 *pulsar.EncryptionContext
	}{result1}
}

func (fake *FakeMessage) GetReplicatedFrom() string {
	fake.getReplicatedFromMutex.Lock()
	ret, specificReturn := fake.getReplicatedFromReturnsOnCall[len(fake.getReplicatedFromArgsForCall)]
	fake.getReplicatedFromArgsForCall = append(fake.getReplicatedFromArgsForCall, struct {
	}{})
	stub := fake.GetReplicatedFromStub
	fakeReturns := fake.getReplicatedFromReturns
	fake.recordInvocation("GetReplicatedFrom", []interface{}{})
	fake.getReplicatedFromMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMessage) GetReplicatedFromCallCount() int {
	fake.getReplicatedFromMutex.RLock()
	defer fake.getReplicatedFromMutex.RUnlock()
	return len(fake.getReplicatedFromArgsForCall)
}

func (fake *FakeMessage) GetReplicatedFromCalls(stub func() string) {
	fake.getReplicatedFromMutex.Lock()
	defer fake.getReplicatedFromMutex.Unlock()
	fake.GetReplicatedFromStub = stub
}

func (fake *FakeMessage) GetReplicatedFromReturns(result1 string) {
	fake.getReplicatedFromMutex.Lock()
	defer fake.getReplicatedFromMutex.Unlock()
	fake.GetReplicatedFromStub = nil
	fake.getReplicatedFromReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeMessage) GetReplicatedFromReturnsOnCall(i int, result1 string) {
	fake.getReplicatedFromMutex.Lock()
	defer fake.getReplicatedFromMutex.Unlock()
	fake.GetReplicatedFromStub = nil
	if fake.getReplicatedFromReturnsOnCall == nil {
		fake.getReplicatedFromReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getReplicatedFromReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeMessage) GetSchemaValue(arg1 interface{}) error {
	fake.getSchemaValueMutex.Lock()
	ret, specificReturn := fake.getSchemaValueReturnsOnCall[len(fake.getSchemaValueArgsForCall)]
	fake.getSchemaValueArgsForCall = append(fake.getSchemaValueArgsForCall, struct {
		arg1 interface{}
	}{arg1})
	stub := fake.GetSchemaValueStub
	fakeReturns := fake.getSchemaValueReturns
	fake.recordInvocation("GetSchemaValue", []interface{}{arg1})
	fake.getSchemaValueMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMessage) GetSchemaValueCallCount() int {
	fake.getSchemaValueMutex.RLock()
	defer fake.getSchemaValueMutex.RUnlock()
	return len(fake.getSchemaValueArgsForCall)
}

func (fake *FakeMessage) GetSchemaValueCalls(stub func(interface{}) error) {
	fake.getSchemaValueMutex.Lock()
	defer fake.getSchemaValueMutex.Unlock()
	fake.GetSchemaValueStub = stub
}

func (fake *FakeMessage) GetSchemaValueArgsForCall(i int) interface{} {
	fake.getSchemaValueMutex.RLock()
	defer fake.getSchemaValueMutex.RUnlock()
	argsForCall := fake.getSchemaValueArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeMessage) GetSchemaValueReturns(result1 error) {
	fake.getSchemaValueMutex.Lock()
	defer fake.getSchemaValueMutex.Unlock()
	fake.GetSchemaValueStub = nil
	fake.getSchemaValueReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeMessage) GetSchemaValueReturnsOnCall(i int, result1 error) {
	fake.getSchemaValueMutex.Lock()
	defer fake.getSchemaValueMutex.Unlock()
	fake.GetSchemaValueStub = nil
	if fake.getSchemaValueReturnsOnCall == nil {
		fake.getSchemaValueReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.getSchemaValueReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeMessage) ID() pulsar.MessageID {
	fake.iDMutex.Lock()
	ret, specificReturn := fake.iDReturnsOnCall[len(fake.iDArgsForCall)]
	fake.iDArgsForCall = append(fake.iDArgsForCall, struct {
	}{})
	stub := fake.IDStub
	fakeReturns := fake.iDReturns
	fake.recordInvocation("ID", []interface{}{})
	fake.iDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMessage) IDCallCount() int {
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	return len(fake.iDArgsForCall)
}

func (fake *FakeMessage) IDCalls(stub func() pulsar.MessageID) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = stub
}

func (fake *FakeMessage) IDReturns(result1 pulsar.MessageID) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	fake.iDReturns = struct {
		result1 pulsar.MessageID
	}{result1}
}

func (fake *FakeMessage) IDReturnsOnCall(i int, result1 pulsar.MessageID) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	if fake.iDReturnsOnCall == nil {
		fake.iDReturnsOnCall = make(map[int]struct {
			result1 pulsar.MessageID
		})
	}
	fake.iDReturnsOnCall[i] = struct {
		result1 pulsar.MessageID
	}{result1}
}

func (fake *FakeMessage) Index() *uint64 {
	fake.indexMutex.Lock()
	ret, specificReturn := fake.indexReturnsOnCall[len(fake.indexArgsForCall)]
	fake.indexArgsForCall = append(fake.indexArgsForCall, struct {
	}{})
	stub := fake.IndexStub
	fakeReturns := fake.indexReturns
	fake.recordInvocation("Index", []interface{}{})
	fake.indexMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMessage) IndexCallCount() int {
	fake.indexMutex.RLock()
	defer fake.indexMutex.RUnlock()
	return len(fake.indexArgsForCall)
}

func (fake *FakeMessage) IndexCalls(stub func() *uint64) {
	fake.indexMutex.Lock()
	defer fake.indexMutex.Unlock()
	fake.IndexStub = stub
}

func (fake *FakeMessage) IndexReturns(result1 *uint64) {
	fake.indexMutex.Lock()
	defer fake.indexMutex.Unlock()
	fake.IndexStub = nil
	fake.indexReturns = struct {
		result1 *uint64
	}{result1}
}

func (fake *FakeMessage) IndexReturnsOnCall(i int, result1 *uint64) {
	fake.indexMutex.Lock()
	defer fake.indexMutex.Unlock()
	fake.IndexStub = nil
	if fake.indexReturnsOnCall == nil {
		fake.indexReturnsOnCall = make(map[int]struct {
			result1 *uint64
		})
	}
	fake.indexReturnsOnCall[i] = struct {
		result1 *uint64
	}{result1}
}

func (fake *FakeMessage) IsReplicated() bool {
	fake.isReplicatedMutex.Lock()
	ret, specificReturn := fake.isReplicatedReturnsOnCall[len(fake.isReplicatedArgsForCall)]
	fake.isReplicatedArgsForCall = append(fake.isReplicatedArgsForCall, struct {
	}{})
	stub := fake.IsReplicatedStub
	fakeReturns := fake.isReplicatedReturns
	fake.recordInvocation("IsReplicated", []interface{}{})
	fake.isReplicatedMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMessage) IsReplicatedCallCount() int {
	fake.isReplicatedMutex.RLock()
	defer fake.isReplicatedMutex.RUnlock()
	return len(fake.isReplicatedArgsForCall)
}

func (fake *FakeMessage) IsReplicatedCalls(stub func() bool) {
	fake.isReplicatedMutex.Lock()
	defer fake.isReplicatedMutex.Unlock()
	fake.IsReplicatedStub = stub
}

func (fake *FakeMessage) IsReplicatedReturns(result1 bool) {
	fake.isReplicatedMutex.Lock()
	defer fake.isReplicatedMutex.Unlock()
	fake.IsReplicatedStub = nil
	fake.isReplicatedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeMessage) IsReplicatedReturnsOnCall(i int, result1 bool) {
	fake.isReplicatedMutex.Lock()
	defer fake.isReplicatedMutex.Unlock()
	fake.IsReplicatedStub = nil
	if fake.isReplicatedReturnsOnCall == nil {
		fake.isReplicatedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isReplicatedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeMessage) Key() string {
	fake.keyMutex.Lock()
	ret, specificReturn := fake.keyReturnsOnCall[len(fake.keyArgsForCall)]
	fake.keyArgsForCall = append(fake.keyArgsForCall, struct {
	}{})
	stub := fake.KeyStub
	fakeReturns := fake.keyReturns
	fake.recordInvocation("Key", []interface{}{})
	fake.keyMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMessage) KeyCallCount() int {
	fake.keyMutex.RLock()
	defer fake.keyMutex.RUnlock()
	return len(fake.keyArgsForCall)
}

func (fake *FakeMessage) KeyCalls(stub func() string) {
	fake.keyMutex.Lock()
	defer fake.keyMutex.Unlock()
	fake.KeyStub = stub
}

func (fake *FakeMessage) KeyReturns(result1 string) {
	fake.keyMutex.Lock()
	defer fake.keyMutex.Unlock()
	fake.KeyStub = nil
	fake.keyReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeMessage) KeyReturnsOnCall(i int, result1 string) {
	fake.keyMutex.Lock()
	defer fake.keyMutex.Unlock()
	fake.KeyStub = nil
	if fake.keyReturnsOnCall == nil {
		fake.keyReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.keyReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeMessage) OrderingKey() string {
	fake.orderingKeyMutex.Lock()
	ret, specificReturn := fake.orderingKeyReturnsOnCall[len(fake.orderingKeyArgsForCall)]
	fake.orderingKeyArgsForCall = append(fake.orderingKeyArgsForCall, struct {
	}{})
	stub := fake.OrderingKeyStub
	fakeReturns := fake.orderingKeyReturns
	fake.recordInvocation("OrderingKey", []interface{}{})
	fake.orderingKeyMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMessage) OrderingKeyCallCount() int {
	fake.orderingKeyMutex.RLock()
	defer fake.orderingKeyMutex.RUnlock()
	return len(fake.orderingKeyArgsForCall)
}

func (fake *FakeMessage) OrderingKeyCalls(stub func() string) {
	fake.orderingKeyMutex.Lock()
	defer fake.orderingKeyMutex.Unlock()
	fake.OrderingKeyStub = stub
}

func (fake *FakeMessage) OrderingKeyReturns(result1 string) {
	fake.orderingKeyMutex.Lock()
	defer fake.orderingKeyMutex.Unlock()
	fake.OrderingKeyStub = nil
	fake.orderingKeyReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeMessage) OrderingKeyReturnsOnCall(i int, result1 string) {
	fake.orderingKeyMutex.Lock()
	defer fake.orderingKeyMutex.Unlock()
	fake.OrderingKeyStub = nil
	if fake.orderingKeyReturnsOnCall == nil {
		fake.orderingKeyReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.orderingKeyReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeMessage) Payload() []byte {
	fake.payloadMutex.Lock()
	ret, specificReturn := fake.payloadReturnsOnCall[len(fake.payloadArgsForCall)]
	fake.payloadArgsForCall = append(fake.payloadArgsForCall, struct {
	}{})
	stub := fake.PayloadStub
	fakeReturns := fake.payloadReturns
	fake.recordInvocation("Payload", []interface{}{})
	fake.payloadMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMessage) PayloadCallCount() int {
	fake.payloadMutex.RLock()
	defer fake.payloadMutex.RUnlock()
	return len(fake.payloadArgsForCall)
}

func (fake *FakeMessage) PayloadCalls(stub func() []byte) {
	fake.payloadMutex.Lock()
	defer fake.payloadMutex.Unlock()
	fake.PayloadStub = stub
}

func (fake *FakeMessage) PayloadReturns(result1 []byte) {
	fake.payloadMutex.Lock()
	defer fake.payloadMutex.Unlock()
	fake.PayloadStub = nil
	fake.payloadReturns = struct {
		result1 []byte
	}{result1}
}

func (fake *FakeMessage) PayloadReturnsOnCall(i int, result1 []byte) {
	fake.payloadMutex.Lock()
	defer fake.payloadMutex.Unlock()
	fake.PayloadStub = nil
	if fake.payloadReturnsOnCall == nil {
		fake.payloadReturnsOnCall = make(map[int]struct {
			result1 []byte
		})
	}
	fake.payloadReturnsOnCall[i] = struct {
		result1 []byte
	}{result1}
}

func (fake *FakeMessage) ProducerName() string {
	fake.producerNameMutex.Lock()
	ret, specificReturn := fake.producerNameReturnsOnCall[len(fake.producerNameArgsForCall)]
	fake.producerNameArgsForCall = append(fake.producerNameArgsForCall, struct {
	}{})
	stub := fake.ProducerNameStub
	fakeReturns := fake.producerNameReturns
	fake.recordInvocation("ProducerName", []interface{}{})
	fake.producerNameMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMessage) ProducerNameCallCount() int {
	fake.producerNameMutex.RLock()
	defer fake.producerNameMutex.RUnlock()
	return len(fake.producerNameArgsForCall)
}

func (fake *FakeMessage) ProducerNameCalls(stub func() string) {
	fake.producerNameMutex.Lock()
	defer fake.producerNameMutex.Unlock()
	fake.ProducerNameStub = stub
}

func (fake *FakeMessage) ProducerNameReturns(result1 string) {
	fake.producerNameMutex.Lock()
	defer fake.producerNameMutex.Unlock()
	fake.ProducerNameStub = nil
	fake.producerNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeMessage) ProducerNameReturnsOnCall(i int, result1 string) {
	fake.producerNameMutex.Lock()
	defer fake.producerNameMutex.Unlock()
	fake.ProducerNameStub = nil
	if fake.producerNameReturnsOnCall == nil {
		fake.producerNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.producerNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeMessage) Properties() map[string]string {
	fake.propertiesMutex.Lock()
	ret, specificReturn := fake.propertiesReturnsOnCall[len(fake.propertiesArgsForCall)]
	fake.propertiesArgsForCall = append(fake.propertiesArgsForCall, struct {
	}{})
	stub := fake.PropertiesStub
	fakeReturns := fake.propertiesReturns
	fake.recordInvocation("Properties", []interface{}{})
	fake.propertiesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMessage) PropertiesCallCount() int {
	fake.propertiesMutex.RLock()
	defer fake.propertiesMutex.RUnlock()
	return len(fake.propertiesArgsForCall)
}

func (fake *FakeMessage) PropertiesCalls(stub func() map[string]string) {
	fake.propertiesMutex.Lock()
	defer fake.propertiesMutex.Unlock()
	fake.PropertiesStub = stub
}

func (fake *FakeMessage) PropertiesReturns(result1 map[string]string) {
	fake.propertiesMutex.Lock()
	defer fake.propertiesMutex.Unlock()
	fake.PropertiesStub = nil
	fake.propertiesReturns = struct {
		result1 map[string]string
	}{result1}
}

func (fake *FakeMessage) PropertiesReturnsOnCall(i int, result1 map[string]string) {
	fake.propertiesMutex.Lock()
	defer fake.propertiesMutex.Unlock()
	fake.PropertiesStub = nil
	if fake.propertiesReturnsOnCall == nil {
		fake.propertiesReturnsOnCall = make(map[int]struct {
			result1 map[string]string
		})
	}
	fake.propertiesReturnsOnCall[i] = struct {
		result1 map[string]string
	}{result1}
}

func (fake *FakeMessage) PublishTime() time.Time {
	fake.publishTimeMutex.Lock()
	ret, specificReturn := fake.publishTimeReturnsOnCall[len(fake.publishTimeArgsForCall)]
	fake.publishTimeArgsForCall = append(fake.publishTimeArgsForCall, struct {
	}{})
	stub := fake.PublishTimeStub
	fakeReturns := fake.publishTimeReturns
	fake.recordInvocation("PublishTime", []interface{}{})
	fake.publishTimeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMessage) PublishTimeCallCount() int {
	fake.publishTimeMutex.RLock()
	defer fake.publishTimeMutex.RUnlock()
	return len(fake.publishTimeArgsForCall)
}

func (fake *FakeMessage) PublishTimeCalls(stub func() time.Time) {
	fake.publishTimeMutex.Lock()
	defer fake.publishTimeMutex.Unlock()
	fake.PublishTimeStub = stub
}

func (fake *FakeMessage) PublishTimeReturns(result1 time.Time) {
	fake.publishTimeMutex.Lock()
	defer fake.publishTimeMutex.Unlock()
	fake.PublishTimeStub = nil
	fake.publishTimeReturns = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeMessage) PublishTimeReturnsOnCall(i int, result1 time.Time) {
	fake.publishTimeMutex.Lock()
	defer fake.publishTimeMutex.Unlock()
	fake.PublishTimeStub = nil
	if fake.publishTimeReturnsOnCall == nil {
		fake.publishTimeReturnsOnCall = make(map[int]struct {
			result1 time.Time
		})
	}
	fake.publishTimeReturnsOnCall[i] = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeMessage) RedeliveryCount() uint32 {
	fake.redeliveryCountMutex.Lock()
	ret, specificReturn := fake.redeliveryCountReturnsOnCall[len(fake.redeliveryCountArgsForCall)]
	fake.redeliveryCountArgsForCall = append(fake.redeliveryCountArgsForCall, struct {
	}{})
	stub := fake.RedeliveryCountStub
	fakeReturns := fake.redeliveryCountReturns
	fake.recordInvocation("RedeliveryCount", []interface{}{})
	fake.redeliveryCountMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMessage) RedeliveryCountCallCount() int {
	fake.redeliveryCountMutex.RLock()
	defer fake.redeliveryCountMutex.RUnlock()
	return len(fake.redeliveryCountArgsForCall)
}

func (fake *FakeMessage) RedeliveryCountCalls(stub func() uint32) {
	fake.redeliveryCountMutex.Lock()
	defer fake.redeliveryCountMutex.Unlock()
	fake.RedeliveryCountStub = stub
}

func (fake *FakeMessage) RedeliveryCountReturns(result1 uint32) {
	fake.redeliveryCountMutex.Lock()
	defer fake.redeliveryCountMutex.Unlock()
	fake.RedeliveryCountStub = nil
	fake.redeliveryCountReturns = struct {
		result1 uint32
	}{result1}
}

func (fake *FakeMessage) RedeliveryCountReturnsOnCall(i int, result1 uint32) {
	fake.redeliveryCountMutex.Lock()
	defer fake.redeliveryCountMutex.Unlock()
	fake.RedeliveryCountStub = nil
	if fake.redeliveryCountReturnsOnCall == nil {
		fake.redeliveryCountReturnsOnCall = make(map[int]struct {
			result1 uint32
		})
	}
	fake.redeliveryCountReturnsOnCall[i] = struct {
		result1 uint32
	}{result1}
}

func (fake *FakeMessage) SchemaVersion() []byte {
	fake.schemaVersionMutex.Lock()
	ret, specificReturn := fake.schemaVersionReturnsOnCall[len(fake.schemaVersionArgsForCall)]
	fake.schemaVersionArgsForCall = append(fake.schemaVersionArgsForCall, struct {
	}{})
	stub := fake.SchemaVersionStub
	fakeReturns := fake.schemaVersionReturns
	fake.recordInvocation("SchemaVersion", []interface{}{})
	fake.schemaVersionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMessage) SchemaVersionCallCount() int {
	fake.schemaVersionMutex.RLock()
	defer fake.schemaVersionMutex.RUnlock()
	return len(fake.schemaVersionArgsForCall)
}

func (fake *FakeMessage) SchemaVersionCalls(stub func() []byte) {
	fake.schemaVersionMutex.Lock()
	defer fake.schemaVersionMutex.Unlock()
	fake.SchemaVersionStub = stub
}

func (fake *FakeMessage) SchemaVersionReturns(result1 []byte) {
	fake.schemaVersionMutex.Lock()
	defer fake.schemaVersionMutex.Unlock()
	fake.SchemaVersionStub = nil
	fake.schemaVersionReturns = struct {
		result1 []byte
	}{result1}
}

func (fake *FakeMessage) SchemaVersionReturnsOnCall(i int, result1 []byte) {
	fake.schemaVersionMutex.Lock()
	defer fake.schemaVersionMutex.Unlock()
	fake.SchemaVersionStub = nil
	if fake.schemaVersionReturnsOnCall == nil {
		fake.schemaVersionReturnsOnCall = make(map[int]struct {
			result1 []byte
		})
	}
	fake.schemaVersionReturnsOnCall[i] = struct {
		result1 []byte
	}{result1}
}

func (fake *FakeMessage) Topic() string {
	fake.topicMutex.Lock()
	ret, specificReturn := fake.topicReturnsOnCall[len(fake.topicArgsForCall)]
	fake.topicArgsForCall = append(fake.topicArgsForCall, struct {
	}{})
	stub := fake.TopicStub
	fakeReturns := fake.topicReturns
	fake.recordInvocation("Topic", []interface{}{})
	fake.topicMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMessage) TopicCallCount() int {
	fake.topicMutex.RLock()
	defer fake.topicMutex.RUnlock()
	return len(fake.topicArgsForCall)
}

func (fake *FakeMessage) TopicCalls(stub func() string) {
	fake.topicMutex.Lock()
	defer fake.topicMutex.Unlock()
	fake.TopicStub = stub
}

func (fake *FakeMessage) TopicReturns(result1 string) {
	fake.topicMutex.Lock()
	defer fake.topicMutex.Unlock()
	fake.TopicStub = nil
	fake.topicReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeMessage) TopicReturnsOnCall(i int, result1 string) {
	fake.topicMutex.Lock()
	defer fake.topicMutex.Unlock()
	fake.TopicStub = nil
	if fake.topicReturnsOnCall == nil {
		fake.topicReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.topicReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeMessage) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.brokerPublishTimeMutex.RLock()
	defer fake.brokerPublishTimeMutex.RUnlock()
	fake.eventTimeMutex.RLock()
	defer fake.eventTimeMutex.RUnlock()
	fake.getEncryptionContextMutex.RLock()
	defer fake.getEncryptionContextMutex.RUnlock()
	fake.getReplicatedFromMutex.RLock()
	defer fake.getReplicatedFromMutex.RUnlock()
	fake.getSchemaValueMutex.RLock()
	defer fake.getSchemaValueMutex.RUnlock()
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	fake.indexMutex.RLock()
	defer fake.indexMutex.RUnlock()
	fake.isReplicatedMutex.RLock()
	defer fake.isReplicatedMutex.RUnlock()
	fake.keyMutex.RLock()
	defer fake.keyMutex.RUnlock()
	fake.orderingKeyMutex.RLock()
	defer fake.orderingKeyMutex.RUnlock()
	fake.payloadMutex.RLock()
	defer fake.payloadMutex.RUnlock()
	fake.producerNameMutex.RLock()
	defer fake.producerNameMutex.RUnlock()
	fake.propertiesMutex.RLock()
	defer fake.propertiesMutex.RUnlock()
	fake.publishTimeMutex.RLock()
	defer fake.publishTimeMutex.RUnlock()
	fake.redeliveryCountMutex.RLock()
	defer fake.redeliveryCountMutex.RUnlock()
	fake.schemaVersionMutex.RLock()
	defer fake.schemaVersionMutex.RUnlock()
	fake.topicMutex.RLock()
	defer fake.topicMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeMessage) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ pulsar.Message = new(FakeMessage)

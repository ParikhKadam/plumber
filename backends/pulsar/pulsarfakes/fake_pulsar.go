// Code generated by counterfeiter. DO NOT EDIT.
package pulsarfakes

import (
	"sync"

	"github.com/apache/pulsar-client-go/pulsar"
)

type FakeClient struct {
	CloseStub        func()
	closeMutex       sync.RWMutex
	closeArgsForCall []struct {
	}
	CreateProducerStub        func(pulsar.ProducerOptions) (pulsar.Producer, error)
	createProducerMutex       sync.RWMutex
	createProducerArgsForCall []struct {
		arg1 pulsar.ProducerOptions
	}
	createProducerReturns struct {
		result1 pulsar.Producer
		result2 error
	}
	createProducerReturnsOnCall map[int]struct {
		result1 pulsar.Producer
		result2 error
	}
	CreateReaderStub        func(pulsar.ReaderOptions) (pulsar.Reader, error)
	createReaderMutex       sync.RWMutex
	createReaderArgsForCall []struct {
		arg1 pulsar.ReaderOptions
	}
	createReaderReturns struct {
		result1 pulsar.Reader
		result2 error
	}
	createReaderReturnsOnCall map[int]struct {
		result1 pulsar.Reader
		result2 error
	}
	CreateTableViewStub        func(pulsar.TableViewOptions) (pulsar.TableView, error)
	createTableViewMutex       sync.RWMutex
	createTableViewArgsForCall []struct {
		arg1 pulsar.TableViewOptions
	}
	createTableViewReturns struct {
		result1 pulsar.TableView
		result2 error
	}
	createTableViewReturnsOnCall map[int]struct {
		result1 pulsar.TableView
		result2 error
	}
	SubscribeStub        func(pulsar.ConsumerOptions) (pulsar.Consumer, error)
	subscribeMutex       sync.RWMutex
	subscribeArgsForCall []struct {
		arg1 pulsar.ConsumerOptions
	}
	subscribeReturns struct {
		result1 pulsar.Consumer
		result2 error
	}
	subscribeReturnsOnCall map[int]struct {
		result1 pulsar.Consumer
		result2 error
	}
	TopicPartitionsStub        func(string) ([]string, error)
	topicPartitionsMutex       sync.RWMutex
	topicPartitionsArgsForCall []struct {
		arg1 string
	}
	topicPartitionsReturns struct {
		result1 []string
		result2 error
	}
	topicPartitionsReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClient) Close() {
	fake.closeMutex.Lock()
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct {
	}{})
	stub := fake.CloseStub
	fake.recordInvocation("Close", []interface{}{})
	fake.closeMutex.Unlock()
	if stub != nil {
		fake.CloseStub()
	}
}

func (fake *FakeClient) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *FakeClient) CloseCalls(stub func()) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = stub
}

func (fake *FakeClient) CreateProducer(arg1 pulsar.ProducerOptions) (pulsar.Producer, error) {
	fake.createProducerMutex.Lock()
	ret, specificReturn := fake.createProducerReturnsOnCall[len(fake.createProducerArgsForCall)]
	fake.createProducerArgsForCall = append(fake.createProducerArgsForCall, struct {
		arg1 pulsar.ProducerOptions
	}{arg1})
	stub := fake.CreateProducerStub
	fakeReturns := fake.createProducerReturns
	fake.recordInvocation("CreateProducer", []interface{}{arg1})
	fake.createProducerMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) CreateProducerCallCount() int {
	fake.createProducerMutex.RLock()
	defer fake.createProducerMutex.RUnlock()
	return len(fake.createProducerArgsForCall)
}

func (fake *FakeClient) CreateProducerCalls(stub func(pulsar.ProducerOptions) (pulsar.Producer, error)) {
	fake.createProducerMutex.Lock()
	defer fake.createProducerMutex.Unlock()
	fake.CreateProducerStub = stub
}

func (fake *FakeClient) CreateProducerArgsForCall(i int) pulsar.ProducerOptions {
	fake.createProducerMutex.RLock()
	defer fake.createProducerMutex.RUnlock()
	argsForCall := fake.createProducerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) CreateProducerReturns(result1 pulsar.Producer, result2 error) {
	fake.createProducerMutex.Lock()
	defer fake.createProducerMutex.Unlock()
	fake.CreateProducerStub = nil
	fake.createProducerReturns = struct {
		result1 pulsar.Producer
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreateProducerReturnsOnCall(i int, result1 pulsar.Producer, result2 error) {
	fake.createProducerMutex.Lock()
	defer fake.createProducerMutex.Unlock()
	fake.CreateProducerStub = nil
	if fake.createProducerReturnsOnCall == nil {
		fake.createProducerReturnsOnCall = make(map[int]struct {
			result1 pulsar.Producer
			result2 error
		})
	}
	fake.createProducerReturnsOnCall[i] = struct {
		result1 pulsar.Producer
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreateReader(arg1 pulsar.ReaderOptions) (pulsar.Reader, error) {
	fake.createReaderMutex.Lock()
	ret, specificReturn := fake.createReaderReturnsOnCall[len(fake.createReaderArgsForCall)]
	fake.createReaderArgsForCall = append(fake.createReaderArgsForCall, struct {
		arg1 pulsar.ReaderOptions
	}{arg1})
	stub := fake.CreateReaderStub
	fakeReturns := fake.createReaderReturns
	fake.recordInvocation("CreateReader", []interface{}{arg1})
	fake.createReaderMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) CreateReaderCallCount() int {
	fake.createReaderMutex.RLock()
	defer fake.createReaderMutex.RUnlock()
	return len(fake.createReaderArgsForCall)
}

func (fake *FakeClient) CreateReaderCalls(stub func(pulsar.ReaderOptions) (pulsar.Reader, error)) {
	fake.createReaderMutex.Lock()
	defer fake.createReaderMutex.Unlock()
	fake.CreateReaderStub = stub
}

func (fake *FakeClient) CreateReaderArgsForCall(i int) pulsar.ReaderOptions {
	fake.createReaderMutex.RLock()
	defer fake.createReaderMutex.RUnlock()
	argsForCall := fake.createReaderArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) CreateReaderReturns(result1 pulsar.Reader, result2 error) {
	fake.createReaderMutex.Lock()
	defer fake.createReaderMutex.Unlock()
	fake.CreateReaderStub = nil
	fake.createReaderReturns = struct {
		result1 pulsar.Reader
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreateReaderReturnsOnCall(i int, result1 pulsar.Reader, result2 error) {
	fake.createReaderMutex.Lock()
	defer fake.createReaderMutex.Unlock()
	fake.CreateReaderStub = nil
	if fake.createReaderReturnsOnCall == nil {
		fake.createReaderReturnsOnCall = make(map[int]struct {
			result1 pulsar.Reader
			result2 error
		})
	}
	fake.createReaderReturnsOnCall[i] = struct {
		result1 pulsar.Reader
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreateTableView(arg1 pulsar.TableViewOptions) (pulsar.TableView, error) {
	fake.createTableViewMutex.Lock()
	ret, specificReturn := fake.createTableViewReturnsOnCall[len(fake.createTableViewArgsForCall)]
	fake.createTableViewArgsForCall = append(fake.createTableViewArgsForCall, struct {
		arg1 pulsar.TableViewOptions
	}{arg1})
	stub := fake.CreateTableViewStub
	fakeReturns := fake.createTableViewReturns
	fake.recordInvocation("CreateTableView", []interface{}{arg1})
	fake.createTableViewMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) CreateTableViewCallCount() int {
	fake.createTableViewMutex.RLock()
	defer fake.createTableViewMutex.RUnlock()
	return len(fake.createTableViewArgsForCall)
}

func (fake *FakeClient) CreateTableViewCalls(stub func(pulsar.TableViewOptions) (pulsar.TableView, error)) {
	fake.createTableViewMutex.Lock()
	defer fake.createTableViewMutex.Unlock()
	fake.CreateTableViewStub = stub
}

func (fake *FakeClient) CreateTableViewArgsForCall(i int) pulsar.TableViewOptions {
	fake.createTableViewMutex.RLock()
	defer fake.createTableViewMutex.RUnlock()
	argsForCall := fake.createTableViewArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) CreateTableViewReturns(result1 pulsar.TableView, result2 error) {
	fake.createTableViewMutex.Lock()
	defer fake.createTableViewMutex.Unlock()
	fake.CreateTableViewStub = nil
	fake.createTableViewReturns = struct {
		result1 pulsar.TableView
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreateTableViewReturnsOnCall(i int, result1 pulsar.TableView, result2 error) {
	fake.createTableViewMutex.Lock()
	defer fake.createTableViewMutex.Unlock()
	fake.CreateTableViewStub = nil
	if fake.createTableViewReturnsOnCall == nil {
		fake.createTableViewReturnsOnCall = make(map[int]struct {
			result1 pulsar.TableView
			result2 error
		})
	}
	fake.createTableViewReturnsOnCall[i] = struct {
		result1 pulsar.TableView
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Subscribe(arg1 pulsar.ConsumerOptions) (pulsar.Consumer, error) {
	fake.subscribeMutex.Lock()
	ret, specificReturn := fake.subscribeReturnsOnCall[len(fake.subscribeArgsForCall)]
	fake.subscribeArgsForCall = append(fake.subscribeArgsForCall, struct {
		arg1 pulsar.ConsumerOptions
	}{arg1})
	stub := fake.SubscribeStub
	fakeReturns := fake.subscribeReturns
	fake.recordInvocation("Subscribe", []interface{}{arg1})
	fake.subscribeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) SubscribeCallCount() int {
	fake.subscribeMutex.RLock()
	defer fake.subscribeMutex.RUnlock()
	return len(fake.subscribeArgsForCall)
}

func (fake *FakeClient) SubscribeCalls(stub func(pulsar.ConsumerOptions) (pulsar.Consumer, error)) {
	fake.subscribeMutex.Lock()
	defer fake.subscribeMutex.Unlock()
	fake.SubscribeStub = stub
}

func (fake *FakeClient) SubscribeArgsForCall(i int) pulsar.ConsumerOptions {
	fake.subscribeMutex.RLock()
	defer fake.subscribeMutex.RUnlock()
	argsForCall := fake.subscribeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) SubscribeReturns(result1 pulsar.Consumer, result2 error) {
	fake.subscribeMutex.Lock()
	defer fake.subscribeMutex.Unlock()
	fake.SubscribeStub = nil
	fake.subscribeReturns = struct {
		result1 pulsar.Consumer
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SubscribeReturnsOnCall(i int, result1 pulsar.Consumer, result2 error) {
	fake.subscribeMutex.Lock()
	defer fake.subscribeMutex.Unlock()
	fake.SubscribeStub = nil
	if fake.subscribeReturnsOnCall == nil {
		fake.subscribeReturnsOnCall = make(map[int]struct {
			result1 pulsar.Consumer
			result2 error
		})
	}
	fake.subscribeReturnsOnCall[i] = struct {
		result1 pulsar.Consumer
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) TopicPartitions(arg1 string) ([]string, error) {
	fake.topicPartitionsMutex.Lock()
	ret, specificReturn := fake.topicPartitionsReturnsOnCall[len(fake.topicPartitionsArgsForCall)]
	fake.topicPartitionsArgsForCall = append(fake.topicPartitionsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.TopicPartitionsStub
	fakeReturns := fake.topicPartitionsReturns
	fake.recordInvocation("TopicPartitions", []interface{}{arg1})
	fake.topicPartitionsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) TopicPartitionsCallCount() int {
	fake.topicPartitionsMutex.RLock()
	defer fake.topicPartitionsMutex.RUnlock()
	return len(fake.topicPartitionsArgsForCall)
}

func (fake *FakeClient) TopicPartitionsCalls(stub func(string) ([]string, error)) {
	fake.topicPartitionsMutex.Lock()
	defer fake.topicPartitionsMutex.Unlock()
	fake.TopicPartitionsStub = stub
}

func (fake *FakeClient) TopicPartitionsArgsForCall(i int) string {
	fake.topicPartitionsMutex.RLock()
	defer fake.topicPartitionsMutex.RUnlock()
	argsForCall := fake.topicPartitionsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) TopicPartitionsReturns(result1 []string, result2 error) {
	fake.topicPartitionsMutex.Lock()
	defer fake.topicPartitionsMutex.Unlock()
	fake.TopicPartitionsStub = nil
	fake.topicPartitionsReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) TopicPartitionsReturnsOnCall(i int, result1 []string, result2 error) {
	fake.topicPartitionsMutex.Lock()
	defer fake.topicPartitionsMutex.Unlock()
	fake.TopicPartitionsStub = nil
	if fake.topicPartitionsReturnsOnCall == nil {
		fake.topicPartitionsReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.topicPartitionsReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	fake.createProducerMutex.RLock()
	defer fake.createProducerMutex.RUnlock()
	fake.createReaderMutex.RLock()
	defer fake.createReaderMutex.RUnlock()
	fake.createTableViewMutex.RLock()
	defer fake.createTableViewMutex.RUnlock()
	fake.subscribeMutex.RLock()
	defer fake.subscribeMutex.RUnlock()
	fake.topicPartitionsMutex.RLock()
	defer fake.topicPartitionsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ pulsar.Client = new(FakeClient)
